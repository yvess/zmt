#!/usr/bin/env python3
# coding: utf-8

import argparse
import subprocess
import configparser
import os
import sys
import traceback
import inspect
from datetime import datetime
from collections import OrderedDict

AUTOSNAP_DATESTR = '%Y-%m-%d_%H:%M:%S'


class Filesystem:
    def __init__(self, name, kind='vm', config=None):
        self.name = name.strip()
        self.kind = kind
        self.zfs_main = config[kind]['zfs_main']
        self.zfs_backup = None
        if 'zfs_backup' in config[kind]:
            self.zfs_backup = config[kind]['zfs_backup']

        self.host_mirror = None
        if 'host_mirror' in config[kind]:
            self.host_mirror = config[kind]['host_mirror']

        self.autosnaps_keep = int(config['defaults']['autosnaps_keep'])
        if 'autosnaps_keep' in config[kind]:
            self.autosnaps_keep = int(config[kind]['autosnaps_keep'])

        self.backupsnaps_keep = int(config['defaults']['backupsnaps_keep'])
        if ('backupsnaps_keep_%s' % self.name) in config[kind]:
            self.backupsnaps_keep = int(config[kind]['backupsnaps_keep_%s' % self.name])
        elif 'backupsnaps_keep' in config[kind]:
            self.backupsnaps_keep = int(config[kind]['backupsnaps_keep'])

    @property
    def longname(self):
        return "%s@%s" % (self.name, self.kind)

    @property
    def main_fs(self):
        return "%s/%s" % (self.zfs_main, self.name)

    @property
    def backup_fs(self):
        return "%s/%s" % (self.zfs_backup, self.name)

    def mount(self):
        cmd = 'zfs list -o name -H -r %s' % self.main_fs
        fs_childs = subprocess.check_output(cmd.split(' '), universal_newlines=True).splitlines()
        for fs in fs_childs:
            subprocess.check_call(['zfs', 'mount', '%s' % fs], universal_newlines=True)

    def umount(self):
        cmd = 'zfs list -o name -H -r %s' % self.main_fs
        fs_childs = subprocess.check_output(cmd.split(' '), universal_newlines=True).splitlines()
        for fs in reversed(fs_childs):
            subprocess.check_call(['zfs', 'umount', '%s' % fs], universal_newlines=True)

    def __str__(self):
        return self.longname

    def __repr__(self):
        return self.longname

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash(tuple(sorted(self.__dict__.items())))


class ZfsTools:
    def __init__(self, args, config):
        self.args = args
        self.config = config
        self.running = []
        self.managed_containers, self.managed_vms = [], []
        self.zmt_path = os.path.abspath(sys.argv[0])
        if 'container' in self.config:
            self.managed_containers = self.config['container']['managed'].split(',')
        if 'vm' in self.config:
            self.managed_vms = self.config['vm']['managed'].split(',')
        self.managed_fs = (
            self._to_filesystem(self.managed_vms) +
            self._to_filesystem(self.managed_containers)
        )
        self._update_running()

    def _update_running(self):
        self.running = self._get_running_vms() + self._get_running_containers()

    def _make_running_list(self, items, managed_items, kind='vm'):
        running_items = [
            Filesystem(item, kind, self.config)
            for item in items
            if item and item in managed_items
        ]
        return running_items

    def _get_running_vms(self):
        running_vms = subprocess.check_output(
            'virsh list --name',
            universal_newlines=True, shell=True
        ).splitlines()
        return self._make_running_list(
            running_vms, self.managed_vms, kind='vm'
        )

    def _get_running_containers(self):
        has_running_containers = subprocess.check_output(
            'docker ps -q',
            universal_newlines=True, shell=True
        ).splitlines()
        if has_running_containers:
            running_containers = subprocess.check_output(
                'docker ps -q|xargs docker inspect --format "{{.Name}}"|\
                 grep -oP "(?<=^/)[a-zA-Z0-9]*(?=_.*)"|sort|uniq',
                universal_newlines=True, shell=True
            ).splitlines()
            return self._make_running_list(
                running_containers, self.managed_containers, kind='container'
            )
        else:
            return []

    def _get_last_snap_from_file(self, snap_fname):
        snap_fname = '/var/lib/zmt/%s' % snap_fname
        if os.path.exists(snap_fname):
            with open(snap_fname) as last_snap_f:
                last_snap = last_snap_f.read().strip()
            return last_snap

    def _get_inc_from_file(self, snap_fname, inc_as_stream=False):
        last_snap = self._get_last_snap_from_file(snap_fname)
        inc = ('-I @%s' if inc_as_stream else '-i @%s') % last_snap
        return inc

    def _get_last_snap_from_zfs(self, fs):
        # get all snapshots from tank
        cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs_main}/{fs}'.format(
            fs=fs.name, zfs_main=fs.zfs_main
        )
        snap_names = subprocess.check_output(
            cmd, universal_newlines=True, shell=True
        ).splitlines()
        if snap_names[0] and '@autosnap-' in snap_names[0]:
            return ''.join(snap_names[0].partition("@autosnap-")[1:])[1:]
        else:
            print("the last snapshot needs to be a autosnap snapshot from zmt")
            exit(1)

    def _get_snap_file_path(self, fs, snap_type="autosnap"):
        snap_fname = '/var/lib/zmt/%s/%s' % (snap_type, fs.longname)
        return snap_fname

    def _write_snap_file(self, snap_fname, snap_name):
        if not os.path.exists('/var/lib/zmt/autosnap/'):
            os.makedirs('/var/lib/zmt/autosnap/')
        snap_fname = '/var/lib/zmt/%s' % snap_fname
        with open(snap_fname, 'w') as last_snap:
            last_snap.write(snap_name)

    def _get_snap_name(self, fq_snap_name):
        return fq_snap_name.split('@')[1]

    def _host_is_up(self, host):
        if '@' not in host:
            return True
        # check if host mirror is reachable
        cmd = 'ping -O -c 1 %s' % host
        ping_exitcode, ping_output = subprocess.getstatusoutput(cmd)
        if ping_exitcode == 0:
            return True
        else:
            return False

    def _to_filesystem(self, items):
        kind_items = []
        for item in items:
            if item in self.managed_vms and item in self.managed_containers:
                raise RuntimeError(
                    "The item name is ambiguous. Please be more specific with @vm or @container"
                )
            if '@vm' in item or '@container' in item:
                name, kind = item.split('@')
            else:
                if item in self.managed_vms:
                    kind = 'vm'
                if item in self.managed_containers:
                    kind = 'container'
                name = item
            kind_items.append(Filesystem(name, kind, self.config))
        return kind_items

    def autosnap(self):
        if not self.args.items and not self.running:
            print('No vms/containers running and no vm/container specified')
            exit(0)

        if self.args.items:
            fs_to_snap = self._to_filesystem(self.args.items)
        else:
            fs_to_snap = self.running
        self._autosnap(fs_to_snap)

    def _autosnap(self, fs_to_snap):
        if not isinstance(fs_to_snap, list):
            fs_to_snap = [fs_to_snap]
        if not os.path.exists('/var/lib/zmt/autosnap/'):
            os.makedirs('/var/lib/zmt/autosnap/')
        now_string = datetime.now().strftime(AUTOSNAP_DATESTR)
        snap_name = 'autosnap-%s' % now_string

        # check if other autosnap is running
        try:
            eq_check = 1 if self.args.command == 'autosnap' else 0
            subprocess.check_call(
                'test $(pgrep -c -f "^python3 %s autosnap") -eq %s' % (self.zmt_path, eq_check),
                universal_newlines=True, shell=True
            )
        except subprocess.CalledProcessError:
            print("other autosnap is running, not autosnapping")
            exit(0)

        # check if a move is running
        try:
            eq_check = 1 if self.args.command == 'move' else 0
            subprocess.check_call(
                'test $(pgrep -c -f "^python3 %s move") -eq %s' % (self.zmt_path, eq_check),
                universal_newlines=True, shell=True
            )
        except subprocess.CalledProcessError:
            print("other move is running, not autosnapping")
            exit(0)

        # create the local snapshots
        for fs in fs_to_snap:
            cmd = 'zfs snap -r {zfs_main}/{fs}@{snap_name}'.format(
                zfs_main=fs.zfs_main, fs=fs.name, snap_name=snap_name
            )
            subprocess.check_call(cmd, universal_newlines=True, shell=True)

        host_mirros_up = {}
        # send all snapshots over ssh to the host_mirror
        for fs in fs_to_snap:
            if fs.host_mirror and fs.host_mirror not in host_mirros_up:
                is_up = self._host_is_up(fs.host_mirror)
                host_mirros_up[fs.host_mirror] = is_up
            if fs.host_mirror and host_mirros_up[fs.host_mirror]:
                last_inc = self._get_inc_from_file(
                    'autosnap/%s' % fs.longname, inc_as_stream=True
                )

                # send fs to host mirror
                cmd = 'zfs send -R {inc} {zfs_main}/{fs}@{snap_name}|\
                       ssh {host_mirror} "zfs recv -u {zfs_main}/{fs}"'.format(
                    zfs_main=fs.zfs_main, fs=fs.name, host_mirror=fs.host_mirror,
                    inc=last_inc, snap_name=snap_name
                )
                subprocess.check_output(
                    cmd, universal_newlines=True, shell=True
                )

                # write last autosnap
                self._write_snap_file(
                    'autosnap/%s' % fs.longname, snap_name
                )
            else:
                if fs.host_mirror:
                    print("Mirror host is down, trying it next time")

    def inspect(self):
        print('* config* ')
        print('managed_containers: %s' % self.managed_containers)
        print('managed_vms: %s' % self.managed_vms)
        print()
        print('* running filesystems to snap *')
        for fs in self.running:
            print(
                '''name: {name}@{kind}
host_mirror: {host_mirror}
zfs_main:{zfs_main}\n'''.format(
                    zfs_main=fs.zfs_main,
                    name=fs.name,
                    host_mirror=fs.host_mirror,
                    kind=fs.kind,
                )
            )

    def _get_fs_mountpoint(self, fs):
        cmd = 'zfs get -H -o value mountpoint %s' % fs.main_fs
        zfs_mountpoint = subprocess.check_output(
            cmd.split(' '), universal_newlines=True
        ).strip()
        return zfs_mountpoint

    def _zmt_mirror_exec(self, zmt_cmd, fs):
        cmd = 'ssh {host_mirror} "{script_path} {zmt_cmd}"'.format(
            host_mirror=fs.host_mirror, script_path=self.zmt_path,
            zmt_cmd=zmt_cmd
        )
        subprocess.check_call(
            cmd, universal_newlines=True, shell=True
        )

    def _zfs_exec(self, zfs_cmd, fs, extra=""):
        cmd = 'zfs {zfs_cmd} {fs_main_fs}'.format(
            zfs_cmd=zfs_cmd, fs_main_fs=fs.main_fs, extra=extra
        )
        subprocess.check_call(
            cmd, universal_newlines=True, shell=True
        )

    def _zfs_mirror_exec(self, zfs_cmd, fs, extra=""):
        cmd = 'ssh {host_mirror} "zfs {zfs_cmd} {fs_main_fs} {extra}"'.format(
            host_mirror=fs.host_mirror, zfs_cmd=zfs_cmd,
            fs_main_fs=fs.main_fs, extra=extra
        )
        subprocess.check_call(
            cmd, universal_newlines=True, shell=True
        )

    def _item_to_fs(self):
        if not self.args.item:
            print('No vm/container specified')
            exit(0)
        try:
            fs = self._to_filesystem(self.args.item)[0]
        except UnboundLocalError:
            print("The filesystem doesn't exists")
            exit(0)
        return fs

    def activate(self):
        fs = self._item_to_fs()
        self._activate(fs)

    def _activate(self, fs):
        # write last autosnap from last zfs snaphost
        self._write_snap_file(
            'autosnap/%s' % fs.longname, self._get_last_snap_from_zfs(fs)
        )

    def deactivate(self):
        fs = self._item_to_fs()
        self._deactivate(fs)

    def _deactivate(self, fs):
        snap_path = self._get_snap_file_path(fs)
        if os.path.exists(snap_path):
            # remove /var/lib/zmt/autosnap file
            if fs not in self.running:
                os.remove(snap_path)

    def _get_autosnap_fs(self):
        return self._to_filesystem(os.listdir('/var/lib/zmt/autosnap'))

    def mount(self):
        items = self._get_autosnap_fs()
        for item in items:
            item.mount()

    def umount(self):
        items = self._get_autosnap_fs()
        for item in items:
            item.umount()

    def start(self):
        if self.args.item:
            all_fs = [self._item_to_fs()]
        else:
            all_fs = self._get_autosnap_fs()

        for fs in all_fs:
            if fs.kind == 'container':
                self._compose(fs, 'up -d')
            if fs.kind == 'vm':
                self._virsh(fs, 'start')

    def stop(self):
        if self.args.item:
            all_fs = [self._item_to_fs()]
        else:
            all_fs = self._get_autosnap_fs()

        for fs in all_fs:
            if fs.kind == 'container':
                self._compose(fs, 'stop')
            if fs.kind == 'vm':
                self._virsh(fs, 'shutdown')

    def move(self):
        # pre checks
        fs = self._item_to_fs()

        if fs not in self.running:
            print('The filesystem must be in use for automatic moving')
            exit(0)
        fs = self._to_filesystem(self.args.item)[0]

        if fs.kind == 'container':
            # container pre checks
            self._zfs_mirror_exec('get -H -o value mounted', fs, extra='|grep -q no')
            last_inc = self._get_last_snap_from_file('autosnap/%s' % fs.longname)
            try:
                self._zfs_mirror_exec('list -H -o name -r -d 1 -t snap', fs, extra='|grep -q %s' % last_inc)
            except subprocess.CalledProcessError:
                print("""stopping move, the previous autosnap (%s) \
does't exists on the target remote filesystem""" % last_inc)
                exit(0)
            try:
                # check for open files/dirs, would break unmount
                subprocess.check_call('! lsof -w|grep /tank/docker/%s' % fs.name, shell=True)
            except subprocess.CalledProcessError:
                print("stopping move, the directory /tank/docker/%s is in use" % fs.name)
                exit(0)

            # doing the move all checks passed
            self._compose(fs, 'stop')
            self._compose(fs, 'rm -f')
            self._autosnap(fs)
            self._deactivate(fs)
            self._zfs_exec('umount', fs)
            self._zfs_mirror_exec('mount', fs)
            self._zmt_mirror_exec("activate %s" % fs.longname, fs)
            self._zmt_mirror_exec("start %s" % fs.longname, fs)

    def _compose(self, fs, compose_cmd="stop"):
        if fs.kind == 'container':
            if 'compose_file' in self.config['container']:
                compose_file = self.config['container']['compose_file']
            else:
                compose_file = 'docker-compose.yml'
            zfs_mountpoint = self._get_fs_mountpoint(fs)
            cmd = 'docker-compose -f %s %s' % (compose_file, compose_cmd)
            subprocess.check_call(
                cmd.split(' '), universal_newlines=True, cwd=zfs_mountpoint
            )
        self._update_running()

    def _virsh(self, fs, virsh_cmd="start"):
        if fs.kind == 'vm':
            cmd = 'virsh %s %s' % (virsh_cmd, fs.name)
            subprocess.check_call(cmd.split(' '), universal_newlines=True)
        self._update_running()

    def _get_backup_snap_names(self, snap_names):
        backup_snap_names = OrderedDict()
        for snap_fullname in snap_names:
            snap_root, snap_name = snap_fullname.split("@")
            if (self.args.backup_snap_name and snap_name == self.args.backup_snap_name) \
               or not self.args.backup_snap_name:
                if snap_root not in backup_snap_names:
                    backup_snap_names[snap_root] = snap_name
        return backup_snap_names

    def backup(self):
        if not os.path.exists('/var/lib/zmt/backup/'):
            os.makedirs('/var/lib/zmt/backup/')

        if self.args.items:
            fs_to_backup = self._to_filesystem(self.args.items)
        else:
            # proccess all managed fs from zmt.ini
            fs_to_backup = self.managed_fs

        failures = ''
        for fs in fs_to_backup:
            try:
                last_inc = self._get_inc_from_file(
                    'backup/%s' % fs.longname, inc_as_stream=False
                )

                # get all snapshots from tank
                cmd = 'zfs list -H -S creation -r -o name -t snap {zfs_main}/{fs}'.format(
                    zfs_main=fs.zfs_main, fs=fs.name, inc=last_inc,
                )
                snap_names = subprocess.check_output(
                    cmd, universal_newlines=True, shell=True
                ).splitlines()

                backup_snap_names = self._get_backup_snap_names(snap_names)
                backup_done = False

                # send only the newest snapshot from tank to backup
                for snap_root, snap_name in backup_snap_names.items():
                    if (last_inc and not last_inc.split('@')[1] in snap_name) or (not last_inc):
                        snap_backup_root = snap_root.replace(fs.zfs_main, fs.zfs_backup)
                        cmd = 'zfs send {last_inc} {snap_root}@{snap_name}|\
                               zfs recv -u {snap_backup_root}'.format(
                            zfs_backup=fs.zfs_backup, fs=fs.name, last_inc=last_inc,
                            snap_name=snap_name, snap_root=snap_root, snap_backup_root=snap_backup_root
                        )
                        if not self.args.test:
                            subprocess.check_output(cmd, universal_newlines=True, shell=True)
                            backup_done = True
                        else:
                            print(cmd.replace('  ', ''))
                    else:
                        print("no newer snapshot to backup for %s" % snap_root)

                if backup_done:
                    # write last backupsnap
                    self._write_snap_file(
                        'backup/%s' % fs.longname, backup_snap_names[fs.main_fs]
                    )

                    # fix mountpoints
                    cmd = 'zfs set mountpoint=/{zfs_backup}/{fs} {zfs_backup}/{fs}'.format(
                        zfs_backup=fs.zfs_backup, fs=fs.name,
                    )
                    subprocess.check_output(
                        cmd, universal_newlines=True, shell=True
                    )
            except:
                failures += traceback.format_exc()
        if failures:
            print(failures)
            sys.exit(1)

    def _list_snaps(self, zfs_root, fs_name):
        cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs_root}/{fs_name}|'
        cmd = (cmd + 'grep "@autosnap-"').format(zfs_root=zfs_root, fs_name=fs_name)
        snaps = subprocess.check_output(
            cmd, universal_newlines=True, shell=True
        ).splitlines()
        return snaps

    def _destroy_snaps(self, snaps, snaps_keep):
        verbose, dry_run = self.args.verbose, self.args.dry_run
        for snap in snaps[snaps_keep:]:
            cmd = 'zfs destroy{verbose}{dry_run} -r {snap}'.format(
                verbose=verbose, dry_run=dry_run, snap=snap
            )
            snap_exitcode, snap_output = subprocess.getstatusoutput(cmd)
            if verbose:
                print(snap_output)

    def cleanup(self):
        for fs in self.managed_fs:
            # normal autosnaps
            if self.args.tank_destroy:
                snaps = self._list_snaps(fs.zfs_main, fs.name)
                if len(snaps) > fs.autosnaps_keep:
                    self._destroy_snaps(snaps, fs.autosnaps_keep)

            # normal backup snaps
            backupsnaps = self._list_snaps(fs.zfs_backup, fs.name)
            if len(backupsnaps) > fs.backupsnaps_keep:
                self._destroy_snaps(backupsnaps, fs.backupsnaps_keep)

        # rsync backup snaps
        for fs_name, host_src in self.config.items('rsync_hosts'):
            backupsnaps = self._list_snaps(self.config['rsync']['zfs_backup'], fs_name)
            backupsnaps_keep = int(self.config['defaults']['backupsnaps_keep'])
            if ('backupsnaps_keep_%s' % fs_name) in self.config['rsync']:
                backupsnaps_keep = int(self.config['rsync']['backupsnaps_keep_%s' % fs_name])
            elif 'backupsnaps_keep' in self.config['rsync']:
                backupsnaps_keep = int(self.config['rsync']['backupsnaps_keep'])

            if len(backupsnaps) > backupsnaps_keep:
                self._destroy_snaps(backupsnaps, backupsnaps_keep)

    def rsync(self):
        if self.args.host:
            rsync_hosts = [(
                self.args.host, self.config['rsync_hosts'][self.args.host]
            )]
        else:
            rsync_hosts = self.config.items('rsync_hosts')
        now_string = datetime.now().strftime(AUTOSNAP_DATESTR)
        verbose, dry_run = self.args.verbose, self.args.dry_run

        failures = ''
        for fs, host_src in rsync_hosts:
            current_failure_tries = 3

            def create_rsync_cmd(host_src):
                dest = '%s/%s' % (self.config['rsync']['dest_path'], fs)
                dest = dest if '/' == dest[:-1] else "%s/" % dest
                excludes = ['--exclude=%s' % exclude for exclude in self.config['rsync']['excludes'].split(',')]
                excludes.insert(0, '')  # space between options
                host_src, delimiter, extra_options = host_src.partition('|')
                if extra_options:
                    extra_options = extra_options.split('|')
                    extra_options.insert(0, '')  # space between options
                cmd = 'rsync {dry_run}{verbose}{options}{excludes}{extra_options} {host_src} {dest}'.format(
                    dry_run=dry_run,
                    verbose=verbose,
                    options=self.config['rsync']['cmd_options'],
                    excludes=' '.join(excludes),
                    extra_options=' '.join(extra_options),
                    host_src=host_src,
                    dest=dest
                )
                # extract hostname
                host_name = host_src.split(':')[0].split('@')[-1]
                if verbose:
                    print("* syncing host:%s" % host_name)
                    print("* with command:\n%s\n" % cmd)
                return (cmd, host_name)

            cmd, host_name = create_rsync_cmd(host_src)
            if self._host_is_up(host_name):
                def exec_rsync_cmd(failures, current_failure_tries, cmd):
                    if current_failure_tries > 1:
                        try:
                            subprocess.check_call(
                                cmd.split(' '), universal_newlines=True
                            )
                            snap_cmd = 'zfs snap -r {zfs_backup}/{fs}@{name}'.format(
                                zfs_backup=self.config['rsync']['zfs_backup'],
                                fs=fs, name='autosnap-%s' % now_string
                            )
                            if verbose:
                                print("* zfs snap rsync with command:\n  %s" % snap_cmd)
                            if dry_run:
                                print("* zfs snap rsync not done, in dry-run mode")
                            else:
                                subprocess.check_call(snap_cmd, shell=True)
                        except:
                            failures += traceback.format_exc()
                            current_failure_tries -= 1
                            failures = exec_rsync_cmd(failures, current_failure_tries, cmd)
                    return failures
                failures = exec_rsync_cmd(failures, current_failure_tries, cmd)
            else:
                print("The host %s is down." % host_name)
        if failures:
            print(failures)
            sys.exit(1)

    def scripts(self):
        if self.args.item:
            scripts_items = [(
                self.args.item, self.config['scripts_items'][self.args.item]
            )]
        else:
            scripts_items = self.config.items('scripts_items')
        now_string = datetime.now().strftime(AUTOSNAP_DATESTR)
        verbose, dry_run = self.args.verbose, self.args.dry_run

        outputs = []
        for fs, script_cmd in scripts_items:
            output = subprocess.check_output(
                script_cmd.split(' '), universal_newlines=True
            )
            if output:
                outputs.append("\n\n%s:%s\n%s" % (fs, script_cmd, output))
            snap_cmd = 'zfs snap -r {zfs_backup}/{fs}@{name}'.format(
                zfs_backup=self.config['scripts']['zfs_backup'],
                fs=fs, name='autosnap-%s' % now_string
            )
            if verbose:
                print("* executing script:\n  %s" % script_cmd)
            if dry_run:
                print("* zfs snap not done, in dry-run mode")
            else:
                subprocess.check_call(snap_cmd, shell=True)
        if outputs:
            print("\n".join(outputs))


class ZfsParser:
    def __init__(self):
        self.parser = argparse.ArgumentParser(
            description="""zfs management tools,
                           for snapshoting, replication, backup""")
        self.subparsers = self.parser.add_subparsers(
            help='avaiable commands')
        for (fname, func) in inspect.getmembers(self, predicate=inspect.ismethod):
            if fname.startswith('parser_'):
                func(self.subparsers)

        self.config = configparser.ConfigParser()
        self.config.read('/etc/zmt/zmt.ini')

    def run(self):
        args = self.parser.parse_args()
        if not hasattr(args, 'command'):
            self.parser.print_help()
            exit(0)
        zfstools = ZfsTools(args, self.config)

        if hasattr(zfstools, args.command):
            getattr(zfstools, args.command)()
        else:
            print('command %s not known' % args.command)

    def parser_autosnap(self, subparsers):
        parser = self.subparsers.add_parser(
            'autosnap',
            help='create a snapshot'
        )
        parser.add_argument('items', nargs='*', default=None)
        parser.set_defaults(command='autosnap')

    def parser_activate(self, subparsers):
        parser = self.subparsers.add_parser(
            'activate',
            help='write latest autosnap to /var/lib/zmt/autosnap'
        )
        parser.add_argument('item', nargs=1)
        parser.set_defaults(command='activate')

    def parser_deactivate(self, subparsers):
        parser = self.subparsers.add_parser(
            'deactivate',
            help='remote latest autosnap file from /var/lib/zmt/autosnap'
        )
        parser.add_argument('item', nargs=1)
        parser.set_defaults(command='deactivate')

    def parser_move(self, subparsers):
        parser = self.subparsers.add_parser(
            'move',
            help='move item to host mirror'
        )
        parser.add_argument('item', nargs=1)
        parser.set_defaults(command='move')

    def parser_start(self, subparsers):
        parser = self.subparsers.add_parser(
            'start',
            help='start one or all container/or vm'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument starts all container/vms"
        )
        parser.set_defaults(command='start')

    def parser_stop(self, subparsers):
        parser = self.subparsers.add_parser(
            'stop',
            help='stop container/or vm'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument stops all container/vms"
        )
        parser.set_defaults(command='stop')

    def parser_backup(self, subparsers):
        parser = self.subparsers.add_parser(
            'backup',
            help='create a backup'
        )
        parser.add_argument(
            '-t', '--test', dest='test', action='store_true',
            default=False, help='only show zfs commands and exit'
        )
        parser.add_argument(
            '-s', '--snap-name', dest='backup_snap_name', action='store',
            default='', help=''
        )
        parser.add_argument('items', nargs='*', default=None)
        parser.set_defaults(command='backup')

    def parser_cleanup(self, subparsers):
        parser = self.subparsers.add_parser(
            'cleanup',
            help='only keep the N recent snapshots'
        )
        parser.add_argument(
            '-v', dest='verbose', const=' -v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-n', dest='dry_run', const=' -n ', action='store_const',
            default='', help='dry-run'
        )
        parser.add_argument(
            '--no-tank-destroy', dest='tank_destroy', action='store_false',
            default=True, help="only delete backup snapshos, don't touch tank"
        )
        parser.set_defaults(command='cleanup')

    def parser_rsync(self, subparsers):
        parser = self.subparsers.add_parser(
            'rsync',
            help='make rsync backups with snapshots'
        )
        parser.add_argument('host', nargs='?', default=None)
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-n', dest='dry_run', const='-n ', action='store_const',
            default='', help='dry-run, no snapshots'
        )
        parser.set_defaults(command='rsync')

    def parser_mount(self, subparsers):
        parser = self.subparsers.add_parser(
            'mount',
            help='mount active filesystems on host'
        )
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.set_defaults(command='mount')

    def parser_umount(self, subparsers):
        parser = self.subparsers.add_parser(
            'umount',
            help='umount active filesystems on host'
        )
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.set_defaults(command='umount')

    def parser_scripts(self, subparsers):
        parser = self.subparsers.add_parser(
            'scripts',
            help='execute a script and make afterwards a snapshot'
        )
        parser.add_argument('item', nargs='?', default=None)
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-n', dest='dry_run', const='-n ', action='store_const',
            default='', help='dry-run, only execute script(s) no snapshot'
        )
        parser.set_defaults(command='scripts')

    def parser_inspect(self, subparsers):
        parser = self.subparsers.add_parser(
            'inspect',
            help='inspect zmt'
        )
        parser.set_defaults(command='inspect')


def main():
    # main parser
    zfs_parser = ZfsParser()
    zfs_parser.run()


if __name__ == '__main__':
    main()
