#!/usr/bin/env python3
# coding: utf-8

from collections import namedtuple
import argparse
import subprocess
import configparser
import os
import sys
import time
import traceback
import inspect
from datetime import datetime
from collections import OrderedDict
import asyncio
from asyncio.subprocess import PIPE

AUTOSNAP_DATESTR = '%Y-%m-%d_%H:%M:%S'
MAX_AUTOSNAP_NR = 4


def split_list(long_list, size):
    lists = []
    while len(long_list) > size:
        pice = long_list[:size]
        lists.append(pice)
        long_list = long_list[size:]
    lists.append(long_list)
    return lists


class Cmd:
    def output(self, cmd, run_async=False, shell=False, split=True, **kwargs):
        # print('# cmd output:', cmd)
        if run_async:
            async def async_cmd():
                if shell:
                    process = await asyncio.create_subprocess_shell(cmd, stdout=PIPE)
                else:
                    cmd_list = [part for part in cmd.split(' ') if part]
                    process = await asyncio.create_subprocess_exec(*cmd_list, stdout=PIPE)
                output = await process.stdout.read()
                returncode = await process.wait()
                if returncode != 0:
                    print("something went wrong with the cmd:'%s' exit:%s" % (cmd, returncode))
                return (returncode, [l for l in output.decode('utf-8').split('\n') if l])
            return async_cmd()
        else:
            if not shell:
                cmd = [part for part in cmd.split(' ') if part]
            output = subprocess.check_output(
                cmd,
                universal_newlines=True, shell=shell
            )
            if split:
                output = output.strip()
                return output.splitlines()
            else:
                return output.strip()

    def call(self, cmd, run_async=False, shell=False, cwd=None, check_returncode=True):
        # print('# cmd call:', cmd)
        if run_async:
            async def async_exec():
                if cwd:
                    kwargs = {'cwd': cwd}
                else:
                    kwargs = {}
                if shell:
                    process = await asyncio.create_subprocess_shell(cmd, **kwargs)
                else:
                    cmd_list = cmd.split(' ')
                    process = await asyncio.create_subprocess_exec(*cmd_list, **kwargs)
                returncode = await process.wait()
                if check_returncode and returncode != 0:
                    print("something went wrong with the cmd:'%s' exit:%s" % (cmd, returncode))
                return returncode
            return async_exec()
        else:
            if not shell:
                cmd = cmd.split(' ')
            subprocess.check_call(cmd, universal_newlines=True, shell=shell, cwd=cwd)


class Filesystem:
    def __init__(self, name, kind='vm', config=None):
        self.cmd = Cmd()
        self.name = name.strip()
        self.kind = kind
        self.zfs_main = config[kind]['zfs_main']
        self.zfs_backup = None
        if 'zfs_backup' in config[kind]:
            self.zfs_backup = config[kind]['zfs_backup']

        self.host_mirror = None
        if 'host_mirror' in config[kind]:
            self.host_mirror = config[kind]['host_mirror']

        self.autosnaps_keep = int(config['defaults']['autosnaps_keep'])
        if 'autosnaps_keep' in config[kind]:
            self.autosnaps_keep = int(config[kind]['autosnaps_keep'])

        self.backupsnaps_keep = int(config['defaults']['backupsnaps_keep'])
        if ('backupsnaps_keep_%s' % self.name) in config[kind]:
            self.backupsnaps_keep = int(config[kind]['backupsnaps_keep_%s' % self.name])
        elif 'backupsnaps_keep' in config[kind]:
            self.backupsnaps_keep = int(config[kind]['backupsnaps_keep'])

    @property
    def longname(self):
        return "%s@%s" % (self.name, self.kind)

    @property
    def main_fs(self):
        return "%s/%s" % (self.zfs_main, self.name)

    @property
    def backup_fs(self):
        return "%s/%s" % (self.zfs_backup, self.name)

    @property
    def autosnap_file(self):
        return self._last_snap_from_file(snap_type='autosnap')

    @property
    def autosnap_file_path(self):
        return '/var/lib/zmt/autosnap/%s' % self.longname

    @property
    def backup_file(self):
        return self._last_snap_from_file(snap_type='backup')

    @property
    def backup_file_path(self):
        return '/var/lib/zmt/backup/%s' % self.longname

    @property
    def autosnap_local(self):
        zfs_cmd = 'list -r -t snap -d 1 -S creation -o name -H'
        cmd = 'zfs {zfs_cmd} {fs.main_fs}|grep "autosnap-"|head -1'.format(zfs_cmd=zfs_cmd, fs=self)
        autosnap_name = self.cmd.output(cmd, shell=True)[0].partition('@')[-1]
        if not autosnap_name:
            print("the last snapshot needs to be a autosnap snapshot from zmt")
            exit(1)
        return autosnap_name

    @property
    def autosnap_mirror(self):
        zfs_cmd = 'list -r -t snap -d 1 -S creation -o name -H'
        cmd = 'ssh {fs.host_mirror} zfs {zfs_cmd} {fs.main_fs}|grep "autosnap-"|head -1'.format(
            zfs_cmd=zfs_cmd, fs=self
        )
        autosnap_name = self.cmd.output(cmd, shell=True)[0].partition('@')[-1]
        if not autosnap_name:
            print("the last snapshot needs to be a autosnap snapshot from zmt")
            exit(1)
        return autosnap_name

    def is_valid_autosnap(self):
        if self.autosnap_file == self.autosnap_local == self.autosnap_mirror:
            return True
        else:
            return False

    def _last_snap_from_file(self, snap_type='autosnap'):
        snap_fname = '/var/lib/zmt/%s/%s' % (snap_type, self.longname)
        if os.path.exists(snap_fname):
            with open(snap_fname) as last_snap_file:
                last_snap = last_snap_file.read().strip()
            return last_snap
        else:
            return None

    def inc_from_file(self, snap_type='autosnap', inc_as_stream=False):
        last_snap = self._last_snap_from_file(snap_type=snap_type)
        if last_snap:
            inc = ('-I @%s' if inc_as_stream else '-i @%s') % last_snap
            return inc
        else:
            return ""

    def write_snap_file(self, snap_type, snap_name):
        snap_fname = '/var/lib/zmt/%s/%s' % (snap_type, self.longname)
        with open(snap_fname, 'w') as last_snap:
            last_snap.write(snap_name)

    def mount_task(self, cmd_zfs='zfs mount %s', reverse=False):
        async def async_mount(items, cmd_zfs=cmd_zfs, reverse=reverse):
            cmd = []
            if reverse:
                items.reverse()
            for item in items:
                fs, mounted = item.split('\t')
                if reverse:
                    if mounted == 'yes':
                        cmd.append(cmd_zfs % fs)
                else:
                    if mounted == 'no':
                        cmd.append(cmd_zfs % fs)
            await self.cmd.call(' && '.join(cmd), shell=True, run_async=True)

        fs_all = self.cmd.output('zfs list -o name,mounted -H -r %s' % self.main_fs)
        return async_mount(fs_all, cmd_zfs=cmd_zfs, reverse=reverse)

    def mount(self):
        loop = asyncio.get_event_loop()
        loop.run_until_complete(self.mount_task())
        loop.close()

    def umount(self):
        loop = asyncio.get_event_loop()
        loop.run_until_complete(self.mount_task(cmd_zfs='zfs umount %s', reverse=True))
        loop.close()

    def __str__(self):
        return self.longname

    def __repr__(self):
        return self.longname

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            def filter(d):
                return {k: v for k, v in d.items() if k in ['kind', 'name']}
            return filter(self.__dict__) == filter(other.__dict__)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash(tuple(sorted(self.__dict__.items())))


class ZfsTools:
    def __init__(self, args, config):
        self.loop = asyncio.get_event_loop()
        self.loop_run = self.loop.run_until_complete
        self.cmd = Cmd()
        self.args = args
        self.config = config
        self.running = []
        self.managed_containers, self.managed_vms = [], []
        self.zmt_path = os.path.abspath(sys.argv[0])
        if 'container' in self.config:
            self.managed_containers = self.config['container']['managed'].split(',')
        if 'vm' in self.config:
            self.managed_vms = self.config['vm']['managed'].split(',')
        self.managed_fs = (
            self._all_to_fs(self.managed_vms) +
            self._all_to_fs(self.managed_containers)
        )

    def close(self):
        self.loop.close()

    def _all_autosnap_fs(self):
        if 'item' in self.args and self.args.item:
            all_fs = [self._item_to_fs()]
        else:
            all_fs = self._autosnap_fs()
        return all_fs

    def _item_to_fs(self):
        item = self.args.item
        if not item:
            print('No vm/container specified')
            exit(1)
        try:
            if not isinstance(item, (list, tuple)):
                item = [item]
            fs = self._all_to_fs(item)[0]
        except UnboundLocalError:
            print("The filesystem doesn't exists")
            exit(1)
        return fs

    def _running_tasks(self):
        return (
            self._running_vms(),
            self._running_containers()
        )

    def _make_running_list(self, items, managed_items, kind='vm'):
        running_items = [
            Filesystem(item, kind, self.config)
            for item in items
            if item and item in managed_items
        ]
        return running_items

    async def _running_vms(self):
        returncode, running_vms = await self.cmd.output('virsh list --name', run_async=True)
        return self._make_running_list(
            running_vms, self.managed_vms, kind='vm'
        )

    async def _running_containers(self):
        returncode, has_running_containers = await self.cmd.output('docker ps -q', run_async=True)
        if has_running_containers:
            cmd = 'docker ps -q|xargs docker inspect --format "{{.Name}}"|' + \
                  'grep -oP "(?<=^/)[a-zA-Z0-9]*(?=_.*)"|sort|uniq'
            returncode, running_containers = await self.cmd.output(cmd, run_async=True, shell=True)
            return self._make_running_list(
                running_containers, self.managed_containers, kind='container'
            )
        else:
            return []

    def _host_is_up(self, host):
        if '@' not in host:
            return True
        # check if host mirror is reachable
        cmd = 'ping -O -c 1 %s' % host
        ping_exitcode, ping_output = subprocess.getstatusoutput(cmd)
        if ping_exitcode == 0:
            return True
        else:
            return False

    def _all_to_fs(self, items):
        kind_items = []
        for item in items:
            if item in self.managed_vms and item in self.managed_containers:
                raise RuntimeError(
                    "The item name is ambiguous. Please be more specific with @vm or @container"
                )
            if '@vm' in item or '@container' in item:
                name, kind = item.split('@')
            else:
                if item in self.managed_vms:
                    kind = 'vm'
                if item in self.managed_containers:
                    kind = 'container'
                name = item
            kind_items.append(Filesystem(name, kind, self.config))
        return kind_items

    def autosnap(self):
        if not os.path.exists('/var/lib/zmt/autosnap/'):
            os.makedirs('/var/lib/zmt/autosnap/')
        self._update_running()
        self._check_running()
        snap_name = self._create_autosnap_name()
        if self.args.items:
            fs_to_snap = self._all_to_fs(self.args.items)
        else:
            fs_to_snap = self.running
        self.loop_run(asyncio.wait(self._autosnap_pre_checks()))
        for fs_chunk in split_list(fs_to_snap, MAX_AUTOSNAP_NR):
            self.loop_run(asyncio.wait(self._autosnap(fs_chunk, snap_name)))
            tasks_results = self.loop_run(asyncio.gather(
                *self._autosnap_send(fs_chunk, snap_name))
            )
            for task in tasks_results:
                if task.has_run:
                    task.fs.write_snap_file('autosnap', task.snap_name)
                else:
                    print("autosnap for fs: %(fs)s, with snap_name: %(snap_name)s, failed" % task._asdict())

    def _autosnap_pre_checks(self):
        async def async_check_other():
            # check if other autosnap is running
            eq_check = 1 if self.args.command == 'autosnap' else 0
            returncode = await self.cmd.call(
                'test $(pgrep -c -f "^python3 %s autosnap") -eq %s' % (self.zmt_path, eq_check),
                shell=True, run_async=True
            )
            if returncode != 0:
                print("other autosnap is running, not autosnapping")
                exit(1)

        async def async_check_move():
            # check if a move is running
            eq_check = 1 if self.args.command == 'move' else 0
            returncode = await self.cmd.call(
                'test $(pgrep -c -f "^python3 %s move") -eq %s' % (self.zmt_path, eq_check),
                shell=True, run_async=True
            )
            if returncode != 0:
                print("other move is running, not autosnapping")
                exit(1)
        return [async_check_other(), async_check_move()]

    def _autosnap(self, fs_to_snap, snap_name):
        if not isinstance(fs_to_snap, list):
            fs_to_snap = [fs_to_snap]

        # create the local snapshots
        tasks = []
        for fs in fs_to_snap:
            async def async_snap(fs):
                returncode = await self.cmd.call(
                    'zfs snap -r {zfs_main}/{fs}@{snap_name}'.format(
                        zfs_main=fs.zfs_main, fs=fs.name, snap_name=snap_name
                    ), run_async=True
                )
                if returncode != 0:
                    print("autosnap went wrong")
                    exit(1)
            tasks.append(async_snap(fs))
        return tasks

    def _autosnap_send(self, fs_to_snap, snap_name):
        host_mirros_up = {}
        tasks = []
        # send all snapshots over ssh to the host_mirror
        for fs in fs_to_snap:
            if fs.host_mirror and fs.host_mirror not in host_mirros_up:
                is_up = self._host_is_up(fs.host_mirror)
                host_mirros_up[fs.host_mirror] = is_up
            if fs.host_mirror and host_mirros_up[fs.host_mirror]:
                last_inc = fs.inc_from_file(snap_type='autosnap', inc_as_stream=True)

                # send fs to host mirror
                cmd = 'zfs send -R {inc} {zfs_main}/{fs}@{snap_name}|\
                       ssh {host_mirror} "zfs recv -u {zfs_main}/{fs}"'.format(
                    zfs_main=fs.zfs_main, fs=fs.name, host_mirror=fs.host_mirror,
                    inc=last_inc, snap_name=snap_name
                )

                async def async_zfs_send(cmd, snap_name, fs):
                    returncode = await self.cmd.call(
                        cmd, shell=True, run_async=True
                    )
                    Result = namedtuple('Result', 'has_run, fs, snap_name')

                    if returncode == 0:
                        return Result(True, fs, snap_name)
                    return Result(False, fs, snap_name)
                tasks.append(async_zfs_send(cmd, snap_name, fs))
            else:
                if fs.host_mirror:
                    print("Mirror host is down, trying it next time")
        return tasks

    def inspect(self):
        print('# config ')
        print('managed_containers: %s' % ", ".join(self.managed_containers))
        print('managed_vms: %s' % ", ".join(self.managed_vms))
        print()
        print('# running filesystems')
        self._update_running()

        for fs in self.running:
            print(
                '''{fs.name}@{fs.kind} host_mirror: {fs.host_mirror} zfs_main:{fs.zfs_main}
- autosnap_from_file : {fs.autosnap_file}
- autosnap_zfs_local : {fs.autosnap_local}
- autosnap_zfs_mirror: {fs.autosnap_mirror}'''.format(fs=fs)
            )
            if not fs.is_valid_autosnap():
                print("ERROR: autosnaps don't match")
            print()

    def _fs_mountpoint(self, fs):
        zfs_mountpoint = self.cmd.output(
            'zfs get -H -o value mountpoint %s' % fs.main_fs, split=False
        )
        return zfs_mountpoint

    async def _zmt_mirror_exec(self, zmt_cmd, fs):
        await self.cmd.call(
            'ssh {host_mirror} "{script_path} {zmt_cmd}"'.format(
                host_mirror=fs.host_mirror, script_path=self.zmt_path,
                zmt_cmd=zmt_cmd
            ), shell=True, run_async=True
        )

    async def _zfs_exec(self, zfs_cmd, fs, extra=""):
        await self.cmd.call(
            'zfs {zfs_cmd} {fs_main_fs}'.format(
                zfs_cmd=zfs_cmd, fs_main_fs=fs.main_fs, extra=extra
            ), run_async=True
        )

    async def _zfs_mirror_exec(self, zfs_cmd, fs, extra=""):
        await self.cmd.call(
            'ssh {host_mirror} "zfs {zfs_cmd} {fs_main_fs} {extra}"'.format(
                host_mirror=fs.host_mirror, zfs_cmd=zfs_cmd,
                fs_main_fs=fs.main_fs, extra=extra
            ), shell=True, run_async=True
        )

    def _update_running(self):
        running_vms, running_containers = self.loop_run(asyncio.gather(
            *self._running_tasks()
        ))
        self.running = running_vms + running_containers

    def _check_running(self):
        if not self.args.items and not self.running:
            print('No vms/containers running and no vm/container specified')
            exit(1)

    def activate(self):
        fs = self._item_to_fs()
        self._activate(fs)

    def _activate(self, fs):
        # write last autosnap from last zfs snaphost
        fs.write_snap_file('autosnap', fs.autosnap_local)

    def deactivate(self):
        fs = self._item_to_fs()
        self.loop_run(asyncio.wait([self._deactivate(fs)]))

    async def _deactivate(self, fs):
        if fs not in self.running:
            await self.cmd.call('rm -f %s' % fs.autosnap_file_path, run_async=True)
        else:
            print("container/vm is running, not deactivating")
            await asyncio.sleep(0)

    def _autosnap_fs(self):
        return self._all_to_fs(os.listdir('/var/lib/zmt/autosnap'))

    def mount(self):
        tasks = []
        for fs in self._all_autosnap_fs():
            tasks.append(fs.mount_task())
        self.loop_run(asyncio.wait(tasks))

    def umount(self):
        tasks = []
        for fs in self._all_autosnap_fs():
            tasks.append(fs.mount_task(cmd_zfs='zfs umount %s', reverse=True))
        self.loop_run(asyncio.wait(tasks))

    def start(self):
        async def async_start(fs):
            if fs.kind == 'container':
                await self._compose(fs, 'up -d', run_async=True)
            if fs.kind == 'vm':
                await self._virsh(fs, 'start', run_async=True)
        tasks = []
        for fs in self._all_autosnap_fs():
            tasks.append(async_start(fs))
        self.loop_run(asyncio.wait(tasks))

    def stop(self, all_fs=None):
        async def async_stop(fs):
            commands = {
                'container': {'stop': 'stop', 'kill': 'kill'},
                'vm': {'stop': 'shutdown', 'kill': 'destroy'},
            }
            cmd = commands[fs.kind][self.args.cmd_stop]
            if fs.kind == 'container':
                await self._compose(fs, cmd, run_async=True)
            if fs.kind == 'vm':
                await self._virsh(fs, cmd, run_async=True)
                returncode = 0

        def check_vm_stop_complete(all_fs):
            all_running_vms = set(self.cmd.output('virsh list --name'))
            all_vms_to_stop = set([fs.name for fs in all_fs if fs.kind == 'vm'])
            if len(all_vms_to_stop - all_running_vms) != len(all_vms_to_stop):
                time.sleep(0.5)
                check_vm_stop_complete(all_fs)

        tasks = []
        fs_to_stop = all_fs or self._all_autosnap_fs()
        for fs in fs_to_stop:
            tasks.append(async_stop(fs))
        self.loop_run(asyncio.wait(tasks))
        check_vm_stop_complete(fs_to_stop)
        self._update_running()

    def autostart(self):
        self.mount()
        self.start()

    async def _async_wait(self, all_fs, func, kwargs={}):
        tasks = []
        for fs in all_fs:
            new_tasks = func(fs, **kwargs)
            if not isinstance(new_tasks, (list, tuple)):
                new_tasks = [new_tasks]
            tasks = tasks + new_tasks
        return await asyncio.wait(tasks)

    def move(self):
        snap_name = self._create_autosnap_name()

        async def async_check_autosnap(fs):
            await self._zfs_mirror_exec('get -H -o value mounted', fs, extra='|grep -q no')
            last_inc = fs.autosnap_file
            try:
                await self._zfs_mirror_exec('list -H -o name -r -d 1 -t snap', fs, extra='|grep -q %s' % last_inc)
            except subprocess.CalledProcessError:
                print("""stopping move, the previous autosnap (%s) \
does't exists on the target remote filesystem""" % last_inc)
                exit(1)

        async def async_check_in_use(fs):
            try:
                # check for open files/dirs, would break unmount
                await self.cmd.call(
                    '! lsof -X -w|grep -q /%s/%s' % (fs.zfs_main, fs.name),
                    shell=True, run_async=True, check_returncode=False
                )
            except subprocess.CalledProcessError:
                print("stopping move, the directory /%s/%s is in use" % (fs.zfs_main, fs.name))
                exit(1)

        def async_mount_cleanup(fs):
            tasks = []

            async def async_umount(fs):
                await fs.mount_task(cmd_zfs='zfs umount %s', reverse=True)
            tasks.append(async_umount(fs))

            async def async_mirror_mount(fs):
                await self._zmt_mirror_exec('mount %s' % fs.name, fs)
            tasks.append(async_mirror_mount(fs))

            async def async_deactivate(fs):
                await self._deactivate(fs)
            tasks.append(async_deactivate(fs))

            return tasks

        async def async_send_cleanup(fs):
            if fs.kind == 'container':
                await self._compose(fs, 'rm -f', run_async=True)
            else:
                await asyncio.sleep(0)

        def async_activate_start(fs):
            tasks = []
            async def async_activate_mirror(fs):
                await self._zmt_mirror_exec("activate %s" % fs.longname, fs)
            tasks.append(async_activate_mirror(fs))

            async def async_start(fs):
                await self._zmt_mirror_exec("start %s" % fs.longname, fs)
            tasks.append(async_start(fs))
            return tasks

        self._update_running()

        if self.args.item:
            fs = self._item_to_fs()
            if fs not in self.running:
                print('The filesystem must be in use for automatic moving')
                exit(1)
            all_fs = [fs]
        else:
            all_fs = self.running
            if self.args.kind:
                all_fs = [fs for fs in all_fs if fs.kind == self.args.kind]
            if not all_fs:
                print('No running container/vm found')
                exit(1)

        self.loop_run(self._async_wait(all_fs, async_check_autosnap))
        self.loop_run(asyncio.wait(self._autosnap_pre_checks()))
        self.stop(all_fs)
        self.loop_run(self._async_wait(all_fs, async_check_in_use))
        self.loop_run(self._async_wait(all_fs, async_send_cleanup))
        for fs_chunk in split_list(all_fs, MAX_AUTOSNAP_NR):
            self.loop_run(self._async_wait(fs_chunk, self._autosnap, dict(snap_name=snap_name)))
            tasks_results = self.loop_run(asyncio.gather(
                *self._autosnap_send(fs_chunk, snap_name))
            )
            for task in tasks_results:
                if task.has_run:
                    task.fs.write_snap_file('autosnap', task.snap_name)
                else:
                    print("autosnap for fs: %(fs)s, with snap_name: %(snap_name)s, failed" % task._asdict())
        self.loop_run(self._async_wait(all_fs, async_mount_cleanup))
        self.loop_run(self._async_wait(all_fs, async_activate_start))

    async def _compose(self, fs, compose_cmd="stop", run_async=False):
        if fs.kind == 'container':
            if 'compose_file' in self.config['container']:
                compose_file = self.config['container']['compose_file']
            else:
                compose_file = 'docker-compose.yml'
            zfs_mountpoint = self._fs_mountpoint(fs)
            await self.cmd.call(
                'docker-compose -f %s %s' % (compose_file, compose_cmd), cwd=zfs_mountpoint, run_async=run_async
            )

    async def _virsh(self, fs, virsh_cmd="start", run_async=False):
        if fs.kind == 'vm':
            await self.cmd.call('virsh %s %s' % (virsh_cmd, fs.name), run_async=run_async)

    def _backup_snap_names(self, snap_names):
        backup_snap_names = OrderedDict()
        for snap_fullname in snap_names:
            snap_root, snap_name = snap_fullname.split("@")
            if (self.args.backup_snap_name and snap_name == self.args.backup_snap_name) \
               or not self.args.backup_snap_name:
                if snap_root not in backup_snap_names:
                    backup_snap_names[snap_root] = snap_name
        return backup_snap_names

    def backup(self):
        if not os.path.exists('/var/lib/zmt/backup/'):
            os.makedirs('/var/lib/zmt/backup/')

        if self.args.items:
            fs_to_backup = self._all_to_fs(self.args.items)
        else:
            # proccess all managed fs from zmt.ini
            fs_to_backup = self.managed_fs

        failures = ''
        for fs in fs_to_backup:
            try:
                last_inc = fs.inc_from_file(snap_type='backup', inc_as_stream=False)

                # get all snapshots from tank
                snap_names = self.cmd.output(
                    'zfs list -H -S creation -r -o name -t snap {zfs_main}/{fs}'.format(
                        zfs_main=fs.zfs_main, fs=fs.name, inc=last_inc,
                    )
                )

                backup_snap_names = self._backup_snap_names(snap_names)
                backup_done = False

                # send only the newest snapshot from tank to backup
                for snap_root, snap_name in backup_snap_names.items():
                    if (last_inc and not last_inc.split('@')[1] in snap_name) or (not last_inc):
                        snap_backup_root = snap_root.replace(fs.zfs_main, fs.zfs_backup)
                        cmd = 'zfs send {last_inc} {snap_root}@{snap_name}|\
                               zfs recv -u {snap_backup_root}'.format(
                            zfs_backup=fs.zfs_backup, fs=fs.name, last_inc=last_inc,
                            snap_name=snap_name, snap_root=snap_root, snap_backup_root=snap_backup_root
                        )
                        if not self.args.test:
                            self.cmd.output(cmd, shell=True)
                            backup_done = True
                        else:
                            print(cmd.replace('  ', ''))
                    else:
                        print("no newer snapshot to backup for %s" % snap_root)

                if backup_done:
                    # write last backupsnap
                    fs.write_snap_file('backup', backup_snap_names[fs.main_fs])

                    # fix mountpoints
                    self.cmd.output(
                        'zfs set mountpoint=/{zfs_backup}/{fs} {zfs_backup}/{fs}'.format(
                            zfs_backup=fs.zfs_backup, fs=fs.name,
                        )
                    )
            except:
                failures += traceback.format_exc()
        if failures:
            print(failures)
            sys.exit(1)

    def _list_snaps(self, zfs_root, fs_name):
        cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs_root}/{fs_name}|'
        cmd = (cmd + 'grep "@autosnap-"').format(zfs_root=zfs_root, fs_name=fs_name)
        snaps = self.cmd.output(cmd, shell=True)
        return snaps

    def _destroy_snaps(self, snaps, snaps_keep):
        verbose, dry_run = self.args.verbose, self.args.dry_run
        for snap in snaps[snaps_keep:]:
            cmd = 'zfs destroy{verbose}{dry_run} -r {snap}'.format(
                verbose=verbose, dry_run=dry_run, snap=snap
            )
            snap_exitcode, snap_output = subprocess.getstatusoutput(cmd)
            if verbose:
                print(snap_output)

    def _create_autosnap_name(self):
        now_string = datetime.now().strftime(AUTOSNAP_DATESTR)
        snap_name = 'autosnap-%s' % now_string
        return snap_name

    def cleanup(self):
        for fs in self.managed_fs:
            # normal autosnaps
            if self.args.tank_destroy:
                snaps = self._list_snaps(fs.zfs_main, fs.name)
                if len(snaps) > fs.autosnaps_keep:
                    self._destroy_snaps(snaps, fs.autosnaps_keep)

            # normal backup snaps
            backupsnaps = self._list_snaps(fs.zfs_backup, fs.name)
            if len(backupsnaps) > fs.backupsnaps_keep:
                self._destroy_snaps(backupsnaps, fs.backupsnaps_keep)

        # rsync backup snaps
        if self.config.has_section('rsync_hosts'):
            for fs_name, host_src in self.config.items('rsync_hosts'):
                backupsnaps = self._list_snaps(self.config['rsync']['zfs_backup'], fs_name)
                backupsnaps_keep = int(self.config['defaults']['backupsnaps_keep'])
                if ('backupsnaps_keep_%s' % fs_name) in self.config['rsync']:
                    backupsnaps_keep = int(self.config['rsync']['backupsnaps_keep_%s' % fs_name])
                elif 'backupsnaps_keep' in self.config['rsync']:
                    backupsnaps_keep = int(self.config['rsync']['backupsnaps_keep'])

                if len(backupsnaps) > backupsnaps_keep:
                    self._destroy_snaps(backupsnaps, backupsnaps_keep)

    def rsync(self):
        if self.args.host:
            rsync_hosts = [(
                self.args.host, self.config['rsync_hosts'][self.args.host]
            )]
        else:
            rsync_hosts = self.config.items('rsync_hosts')
        snap_name = self._create_autosnap_name()
        verbose, dry_run = self.args.verbose, self.args.dry_run

        failures = ''
        for fs, host_src in rsync_hosts:
            current_failure_tries = 3

            def create_rsync_cmd(host_src):
                dest = '%s/%s' % (self.config['rsync']['dest_path'], fs)
                dest = dest if '/' == dest[:-1] else "%s/" % dest
                excludes = ['--exclude=%s' % exclude for exclude in self.config['rsync']['excludes'].split(',')]
                excludes.insert(0, '')  # space between options
                host_src, delimiter, extra_options = host_src.partition('|')
                if extra_options:
                    extra_options = extra_options.split('|')
                    extra_options.insert(0, '')  # space between options
                cmd = 'rsync {dry_run}{verbose}{options}{excludes}{extra_options} {host_src} {dest}'.format(
                    dry_run=dry_run,
                    verbose=verbose,
                    options=self.config['rsync']['cmd_options'],
                    excludes=' '.join(excludes),
                    extra_options=' '.join(extra_options),
                    host_src=host_src,
                    dest=dest
                )
                # extract hostname
                host_name = host_src.split(':')[0].split('@')[-1]
                if verbose:
                    print("* syncing host:%s" % host_name)
                    print("* with command:\n%s\n" % cmd)
                return (cmd, host_name)

            cmd, host_name = create_rsync_cmd(host_src)
            if self._host_is_up(host_name):
                def exec_rsync_cmd(failures, current_failure_tries, cmd):
                    if current_failure_tries > 1:
                        try:
                            self.cmd.call(cmd)
                            snap_cmd = 'zfs snap -r {zfs_backup}/{fs}@{name}'.format(
                                zfs_backup=self.config['rsync']['zfs_backup'],
                                fs=fs, name=snap_name
                            )
                            if verbose:
                                print("* zfs snap rsync with command:\n  %s" % snap_cmd)
                            if dry_run:
                                print("* zfs snap rsync not done, in dry-run mode")
                            else:
                                self.cmd.call(snap_cmd)
                        except:
                            failures += traceback.format_exc()
                            current_failure_tries -= 1
                            failures = exec_rsync_cmd(failures, current_failure_tries, cmd)
                    return failures
                failures = exec_rsync_cmd(failures, current_failure_tries, cmd)
            else:
                print("The host %s is down." % host_name)
        if failures:
            print(failures)
            sys.exit(1)

    def scripts(self):
        if self.args.item:
            scripts_items = [(
                self.args.item, self.config['scripts_items'][self.args.item]
            )]
        else:
            scripts_items = self.config.items('scripts_items')
        verbose, dry_run = self.args.verbose, self.args.dry_run
        snap_name = self._create_autosnap_name()
        outputs = []
        for fs, script_cmd in scripts_items:
            output = self.cmd.output(script_cmd)
            if output:
                outputs.append("\n\n%s:%s\n%s" % (fs, script_cmd, output))
            snap_cmd = 'zfs snap -r {zfs_backup}/{fs}@{name}'.format(
                zfs_backup=self.config['scripts']['zfs_backup'],
                fs=fs, name=snap_name
            )
            if verbose:
                print("* executing script:\n  %s" % script_cmd)
            if dry_run:
                print("* zfs snap not done, in dry-run mode")
            else:
                self.cmd.call(snap_cmd)
        if outputs:
            print("\n".join(outputs))


class ZfsParser:
    def __init__(self):
        self.parser = argparse.ArgumentParser(
            description="""zfs management tools,
                           for snapshoting, replication, backup""")
        self.subparsers = self.parser.add_subparsers(
            help='avaiable commands')
        for (fname, func) in inspect.getmembers(self, predicate=inspect.ismethod):
            if fname.startswith('parser_'):
                func(self.subparsers)

        self.config = configparser.ConfigParser()
        self.config.read('/etc/zmt/zmt.ini')

    def run(self):
        args = self.parser.parse_args()
        if not hasattr(args, 'command'):
            self.parser.print_help()
            exit(0)
        self.zfstools = ZfsTools(args, self.config)

        if hasattr(self.zfstools, args.command):
            getattr(self.zfstools, args.command)()
        else:
            print('command %s not known' % args.command)

    def close(self):
        self.zfstools.close()

    def parser_autosnap(self, subparsers):
        parser = self.subparsers.add_parser(
            'autosnap',
            help='create a snapshot'
        )
        parser.add_argument('items', nargs='*', default=None)
        parser.set_defaults(command='autosnap')

    def parser_activate(self, subparsers):
        parser = self.subparsers.add_parser(
            'activate',
            help='write latest autosnap to /var/lib/zmt/autosnap'
        )
        parser.add_argument('item', nargs=1)
        parser.set_defaults(command='activate')

    def parser_deactivate(self, subparsers):
        parser = self.subparsers.add_parser(
            'deactivate',
            help='remote latest autosnap file from /var/lib/zmt/autosnap'
        )
        parser.add_argument('item', nargs=1)
        parser.set_defaults(command='deactivate')

    def parser_move(self, subparsers):
        parser = self.subparsers.add_parser(
            'move',
            help='move item to host mirror'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument moves all container/vms"
        )
        parser.add_argument(
            '--kill', dest='cmd_stop', action='store_const', const='kill',
            default='stop', help='use kill instead of stop for shutdown'
        )
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            '--container', dest='kind', action='store_const', const='container',
            default='', help='only move containers'
        )
        group.add_argument(
            '--vm', dest='kind', action='store_const', const='vm',
            default='', help='only move vms (not implemented yet)'
        )
        parser.set_defaults(command='move')

    def parser_start(self, subparsers):
        parser = self.subparsers.add_parser(
            'start',
            help='start one or all container/or vm'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument starts all container/vms"
        )
        parser.set_defaults(command='start')

    def parser_autostart(self, subparsers):
        parser = self.subparsers.add_parser(
            'autostart',
            help='mount and start all containers/vms'
        )
        parser.set_defaults(command='autostart')

    def parser_stop(self, subparsers):
        parser = self.subparsers.add_parser(
            'stop',
            help='stop container/or vm'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument stops all container/vms"
        )
        parser.add_argument(
            '--kill', dest='cmd_stop', action='store_const', const='kill',
            default='stop', help='use kill instead of stop for shutdown'
        )
        parser.set_defaults(command='stop')

    def parser_backup(self, subparsers):
        parser = self.subparsers.add_parser(
            'backup',
            help='create a backup'
        )
        parser.add_argument(
            '-t', '--test', dest='test', action='store_true',
            default=False, help='only show zfs commands and exit'
        )
        parser.add_argument(
            '-s', '--snap-name', dest='backup_snap_name', action='store',
            default='', help=''
        )
        parser.add_argument('items', nargs='*', default=None)
        parser.set_defaults(command='backup')

    def parser_cleanup(self, subparsers):
        parser = self.subparsers.add_parser(
            'cleanup',
            help='only keep the N recent snapshots'
        )
        parser.add_argument(
            '-v', dest='verbose', const=' -v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-n', dest='dry_run', const=' -n ', action='store_const',
            default='', help='dry-run'
        )
        parser.add_argument(
            '--no-tank-destroy', dest='tank_destroy', action='store_false',
            default=True, help="only delete backup snapshos, don't touch tank"
        )
        parser.set_defaults(command='cleanup')

    def parser_rsync(self, subparsers):
        parser = self.subparsers.add_parser(
            'rsync',
            help='make rsync backups with snapshots'
        )
        parser.add_argument('host', nargs='?', default=None)
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-n', dest='dry_run', const='-n ', action='store_const',
            default='', help='dry-run, no snapshots'
        )
        parser.set_defaults(command='rsync')

    def parser_mount(self, subparsers):
        parser = self.subparsers.add_parser(
            'mount',
            help='mount active filesystems on host'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument mounts all container/vms"
        )
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.set_defaults(command='mount')

    def parser_umount(self, subparsers):
        parser = self.subparsers.add_parser(
            'umount',
            help='umount active filesystems on host'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument unmounts all container/vms"
        )
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.set_defaults(command='umount')

    def parser_scripts(self, subparsers):
        parser = self.subparsers.add_parser(
            'scripts',
            help='execute a script and make afterwards a snapshot'
        )
        parser.add_argument('item', nargs='?', default=None)
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-n', dest='dry_run', const='-n ', action='store_const',
            default='', help='dry-run, only execute script(s) no snapshot'
        )
        parser.set_defaults(command='scripts')

    def parser_inspect(self, subparsers):
        parser = self.subparsers.add_parser(
            'inspect',
            help='inspect zmt'
        )
        parser.set_defaults(command='inspect')


def main():
    # main parser
    zfs_parser = ZfsParser()
    zfs_parser.run()
    zfs_parser.close()


if __name__ == '__main__':
    main()
