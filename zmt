#!/usr/bin/env python3
# coding: utf-8

from collections import namedtuple
import argparse
import subprocess
import configparser
import os
import sys
import time
import traceback
import inspect
from datetime import datetime
from collections import OrderedDict
import asyncio
from asyncio.subprocess import PIPE

AUTOSNAP_DATECMD = 'date +%Y-%m-%d_%H:%M:%STZ%z'
MAX_AUTOSNAP_NR = 4
LOCK_FILE = '/var/lib/zmt/%s.lock'


def split_list(long_list, size):
    lists = []
    while len(long_list) > size:
        pice = long_list[:size]
        lists.append(pice)
        long_list = long_list[size:]
    lists.append(long_list)
    return lists

def get_config_value(config, name, fs_name='', section='', defaults_fallback=None):
    if section and section in config:
        section_fs_name = "{}_{}".format(name, fs_name)
        if fs_name and section_fs_name in config[section]:
            return config[section][section_fs_name]
        elif name in config[section]:
            return config[section][name]
    if name in config['defaults']:
        return config['defaults'][name]
    elif defaults_fallback in config['defaults']:
        return config['defaults'][defaults_fallback]
    return None


class Cmd:
    def output(self, cmd, run_async=False, shell=False, split=True, cwd=None, **kwargs):
        # print('# cmd output:', cmd) # for debug
        if run_async:
            async def async_cmd():
                if shell:
                    process = await asyncio.create_subprocess_shell(cmd, cwd=cwd, stdout=PIPE)
                else:
                    cmd_list = [part for part in cmd.split(' ') if part]
                    process = await asyncio.create_subprocess_exec(*cmd_list, cwd=cwd, stdout=PIPE)
                output = await process.stdout.read()
                returncode = await process.wait()
                if returncode != 0:
                    print("something went wrong with the cmd:'%s' exit:%s" % (cmd, returncode))
                return (returncode, [l for l in output.decode('utf-8').split('\n') if l])
            return async_cmd()
        else:
            if not shell:
                cmd = [part for part in cmd.split(' ') if part]
            output = subprocess.check_output(
                cmd, universal_newlines=True, shell=shell, cwd=cwd,
            )
            if split:
                output = output.strip()
                return output.splitlines()
            else:
                return output.strip()

    def call(self, cmd, run_async=False, shell=False, cwd=None, check_returncode=True):
        # print('# cmd call:', cmd) # for debug
        if run_async:
            async def async_exec():
                if cwd:
                    kwargs = {'cwd': cwd}
                else:
                    kwargs = {}
                if shell:
                    process = await asyncio.create_subprocess_shell(cmd, **kwargs)
                else:
                    cmd_list = cmd.split(' ')
                    process = await asyncio.create_subprocess_exec(*cmd_list, **kwargs)
                returncode = await process.wait()
                if check_returncode and returncode != 0:
                    print("something went wrong with the cmd:'%s' exit:%s" % (cmd, returncode))
                return returncode
            return async_exec()
        else:
            if not shell:
                cmd = cmd.split(' ')
            subprocess.check_call(cmd, universal_newlines=True, shell=shell, cwd=cwd)


class Filesystem:
    def __init__(self, name, kind='vm', config=None):
        self.cmd = Cmd()
        self.name, self.kind = name.strip(), kind
        kd_conf = config[kind]
        self.zfs_main = kd_conf['zfs_main'] if 'zfs_main' in kd_conf else None
        self.zfs_backup = kd_conf['zfs_backup'] if 'zfs_backup' in kd_conf else None
        self.zfs_backup_host = kd_conf['zfs_backup_host'] if 'zfs_backup_host' in kd_conf else None
        self.options = {}
        if "%s_items" % kind in config and name in config["%s_items" % kind]:
            options_str = config["%s_items" % kind][name]
            if kind in ['vm', 'container'] and ':' in options_str:
                self.options = self._extract_options(options_str)
        self.host_mirror = kd_conf['host_mirror'] if 'host_mirror' in kd_conf else None
        self.autosnaps_keep = int(get_config_value(config, 'autosnaps_keep', self.name, section=kind))
        self.backupsnaps_keep = int(get_config_value(config, 'backupsnaps_keep', self.name, section=kind))

    def _extract_options(self, options_str):
        options = {}
        for option in options_str.split('|'):
            name, _, value = option.partition(':')
            options[name] = value
        return options

    @property
    def longname(self):
        return "%s@%s" % (self.name, self.kind)

    @property
    def main_fs(self):
        return "%s/%s" % (self.zfs_main, self.name)

    @property
    def backup_fs(self):
        return "%s/%s" % (self.zfs_backup, self.name)

    @property
    def autosnap_file(self):
        return self._last_snap_from_file(snap_type='autosnap')

    @property
    def autosnap_file_path(self):
        return '/var/lib/zmt/autosnap/%s' % self.longname

    @property
    def backup_file(self):
        return self._last_snap_from_file(snap_type='backup')

    @property
    def backup_file_path(self):
        return '/var/lib/zmt/backup/%s' % self.longname

    @property
    def autosnap_local(self):
        zfs_cmd = 'list -r -t snap -d 1 -S creation -o name -H'
        cmd = 'zfs {zfs_cmd} {fs.main_fs}|grep "autosnap-"|head -1'.format(zfs_cmd=zfs_cmd, fs=self)
        autosnap_name = self.cmd.output(cmd, shell=True)[0].partition('@')[-1]
        if not autosnap_name:
            print("the last snapshot needs to be a autosnap snapshot from zmt")
            exit(1)
        return autosnap_name

    @property
    def autosnap_mirror(self):
        if self.host_mirror:
            zfs_cmd = 'list -r -t snap -d 1 -S creation -o name -H'
            cmd = 'ssh {fs.host_mirror} zfs {zfs_cmd} {fs.main_fs}|grep "autosnap-"|head -1'.format(
                zfs_cmd=zfs_cmd, fs=self
            )
            autosnap_name = self.cmd.output(cmd, shell=True)[0].partition('@')[-1]
            if not autosnap_name:
                print("the last snapshot needs to be a autosnap snapshot from zmt")
                exit(1)
            return autosnap_name
        return None

    def is_valid_autosnap(self):
        if self.host_mirror:
            if self.autosnap_file == self.autosnap_local == self.autosnap_mirror:
                return True
        elif self.autosnap_file == self.autosnap_local:
            return True
        return False

    def _last_snap_from_file(self, snap_type='autosnap'):
        snap_fname = '/var/lib/zmt/%s/%s' % (snap_type, self.longname)
        if os.path.exists(snap_fname):
            with open(snap_fname) as last_snap_file:
                last_snap = last_snap_file.read().strip()
            return last_snap
        else:
            return None

    def inc_from_file(self, snap_type='autosnap', inc_as_stream=False):
        last_snap = self._last_snap_from_file(snap_type=snap_type)
        if last_snap:
            inc = ('-I @%s' if inc_as_stream else '-i @%s') % last_snap
            return inc
        else:
            return ""

    def write_snap_file(self, snap_type, snap_name):
        snap_fname = '/var/lib/zmt/%s/%s' % (snap_type, self.longname)
        with open(snap_fname, 'w') as last_snap:
            last_snap.write(snap_name)

    def mount_task(self, cmd_zfs='zfs mount %s', reverse=False):
        async def async_mount(items, cmd_zfs=cmd_zfs, reverse=reverse):
            cmd = []
            if reverse:
                items.reverse()
            for item in items:
                fs, mounted = item.split('\t')
                if reverse:
                    if mounted == 'yes':
                        cmd.append(cmd_zfs % fs)
                else:
                    if mounted == 'no':
                        cmd.append(cmd_zfs % fs)
            await self.cmd.call(' && '.join(cmd), shell=True, run_async=True)

        fs_all = self.cmd.output('zfs list -o name,mounted -H -r %s' % self.main_fs)
        return async_mount(fs_all, cmd_zfs=cmd_zfs, reverse=reverse)

    def mount(self):
        loop = asyncio.get_event_loop()
        loop.run_until_complete(self.mount_task())
        loop.close()

    def umount(self):
        loop = asyncio.get_event_loop()
        loop.run_until_complete(self.mount_task(cmd_zfs='zfs umount %s', reverse=True))
        loop.close()

    def __str__(self):
        return self.longname

    def __repr__(self):
        return self.longname

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            def filter(d):
                return {k: v for k, v in d.items() if k in ['kind', 'name']}
            return filter(self.__dict__) == filter(other.__dict__)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash(tuple(sorted(self.__dict__.items())))


class FilesystemManager:
    def __init__(self, config=None, kind='all'):
        self.containers, self.vms, self.rsync, self.scripts, self.plain_items = [], [], [], [], []
        self.managed_containers, self.managed_vms, self.managed_plain_items = [], [], []
        self.config = config
        if config:
            if 'container' in config and 'container_items' in config and kind in ['all', 'container']:
                self.managed_containers = [name for name, options in self.config.items('container_items')]
                self.containers = self.all_to_fs(self.managed_containers)
            if 'vm' in config and 'vm_items' in config and kind in ['all', 'vm']:
                self.managed_vms =  [name for name, options in self.config.items('vm_items')]
                self.vms = self.all_to_fs(self.managed_vms)
            if 'plain' in config and 'plain_items' in config and kind in ['all', 'plain']:
                self.managed_plain_items =  [name for name, options in self.config.items('plain_items')]
                self.plain_items = self.all_to_fs(self.managed_plain_items)
            if 'rsync_items' in config and kind in ['all', 'rsync']:
                for rsync_host in config.items('rsync_items'):
                    name, host_src = rsync_host
                    self.rsync.append(Filesystem(name, kind='rsync', config=config))
            if 'scripts_items' in config and kind in ['all', 'scripts']:
                for item in config.items('scripts_items'):
                    name, script = item
                    self.scripts.append(Filesystem(name, kind='scripts', config=config))
            self.fs = self.vms + self.containers + self.plain_items
            self.fs_backup = self.vms + self.containers + self.rsync + self.scripts

    def all_to_fs(self, items):
        kind_items = []
        for item in items:
            if item in self.managed_vms and item in self.managed_containers:
                raise RuntimeError(
                    "The item name is ambiguous. Please be more specific with @vm, @container or @plain"
                )
            if item.partition('@')[-1] in ['vm', 'container', 'plain']:
                name, kind = item.split('@')
            else:
                if item in self.managed_vms:
                    kind = 'vm'
                elif item in self.managed_containers:
                    kind = 'container'
                elif item in self.managed_plain_items:
                    kind = 'plain'
                name = item
            kind_items.append(Filesystem(name, kind, self.config))
        return kind_items


class ZfsTools:
    def __init__(self, args, config):
        self.loop = asyncio.get_event_loop()
        self.loop_run = self.loop.run_until_complete
        self.cmd = Cmd()
        self.args = args
        self.config = config
        self.running = []
        self.zmt_path = os.path.abspath(sys.argv[0])
        self.fsmanager = FilesystemManager(config)

    def close(self):
        self.loop.close()

    def _all_autosnap_fs(self):
        if 'item' in self.args and self.args.item:
            all_fs = [self._item_to_fs()]
        else:
            all_fs = self._autosnap_fs()
        return all_fs

    def _item_to_fs(self):
        item = self.args.item
        if not item:
            print('No vm/container/plain specified')
            exit(1)
        try:
            if not isinstance(item, (list, tuple)):
                item = [item]
            fs = self.fsmanager.all_to_fs(item)[0]
        except UnboundLocalError:
            print("The filesystem doesn't exists")
            exit(1)
        return fs

    def _running_tasks(self):
        tasks = []
        if self.fsmanager.managed_vms:
            tasks.append(self._running_vms())
        if self.fsmanager.managed_containers:
            tasks.append(self._running_containers())
        return tasks

    def _make_running_list(self, items, managed_items, kind='vm'):
        running_items = [
            Filesystem(item, kind, self.config)
            for item in items
            if item and item in managed_items
        ]
        return running_items

    async def _running_vms(self):
        returncode, running_vms = await self.cmd.output('virsh list --name', run_async=True)
        return self._make_running_list(
            running_vms, self.fsmanager.managed_vms, kind='vm'
        )

    async def _running_containers(self):
        returncode, has_running_containers = await self.cmd.output('docker ps -q', run_async=True)
        if has_running_containers:
            cmd = 'docker ps -q|xargs docker inspect --format "{{.Name}}"|' + \
                  'grep -oP "(?<=^/)[a-zA-Z0-9]*(?=_.*)"|sort|uniq'
            returncode, running_containers = await self.cmd.output(cmd, run_async=True, shell=True)
            return self._make_running_list(
                running_containers, self.fsmanager.managed_containers, kind='container'
            )
        else:
            return []

    def _host_is_up(self, host):
        if '@' not in host:
            return True
        # check if host mirror is reachable
        cmd = 'ping -O -c 1 %s' % host
        ping_exitcode, ping_output = subprocess.getstatusoutput(cmd)
        if ping_exitcode == 0:
            return True
        else:
            return False

    def autosnap(self):
        if not os.path.exists('/var/lib/zmt/autosnap/'):
            os.makedirs('/var/lib/zmt/autosnap/')
        self._update_running()
        self._check_running()
        snap_name = self._create_autosnap_name()
        if self.args.items:
            fs_to_snap = self.fsmanager.all_to_fs(self.args.items)
        else:
            fs_to_snap = self.running
        self._create_lock('autosnap')
        for fs_chunk in split_list(fs_to_snap, MAX_AUTOSNAP_NR):
            self.loop_run(asyncio.wait(self._autosnap(fs_chunk, snap_name)))
            tasks_results = self.loop_run(asyncio.gather(
                *self._autosnap_send(fs_chunk, snap_name))
            )
            for task in tasks_results:
                if task.has_run:
                    task.fs.write_snap_file('autosnap', task.snap_name)
                elif not self.args.test:
                    msg = "autosnap for fs: %(fs)s, with snap_name: %(snap_name)s, failed"
                    print(msg % task._asdict())
        self._remove_lock('autosnap')

    def _create_lock(self, kind):
        if not os.path.exists(LOCK_FILE % kind):
            open(LOCK_FILE % kind, 'a').close()
        else:
            print("other %s is running, aborting" % kind)
            exit(1)

    def _remove_lock(self, kind):
        os.remove(LOCK_FILE % kind)

    def _autosnap(self, fs_to_snap, snap_name):
        if not isinstance(fs_to_snap, list):
            fs_to_snap = [fs_to_snap]

        # create the local snapshots
        tasks = []
        for fs in fs_to_snap:
            async def async_snap(fs, test=False, verbose=''):
                cmd = 'zfs snap -r {zfs_main}/{fs}@{snap_name}'.format(
                    zfs_main=fs.zfs_main, fs=fs.name, snap_name=snap_name
                )
                if test or verbose:
                    print(cmd.replace('   ', ''))
                if test:
                    returncode = await self.cmd.call('true', run_async=True)
                else:
                    returncode = await self.cmd.call(cmd, run_async=True)
                if returncode != 0:
                    print("autosnap went wrong")
                    exit(1)
            test = self.args.test if 'test' in self.args else False
            verbose = self.args.verbose if 'verbose' in self.args else ''
            tasks.append(async_snap(fs, test=test, verbose=verbose))
        return tasks

    def _autosnap_send(self, fs_to_snap, snap_name):
        host_mirros_up = {}
        tasks = []
        # send all snapshots over ssh to the host_mirror
        Result = namedtuple('Result', 'has_run, fs, snap_name')
        for fs in fs_to_snap:
            if fs.host_mirror:
                if fs.host_mirror not in host_mirros_up:
                    is_up = self._host_is_up(fs.host_mirror)
                    host_mirros_up[fs.host_mirror] = is_up
                if host_mirros_up[fs.host_mirror]:
                    last_inc = fs.inc_from_file(snap_type='autosnap', inc_as_stream=True)

                    # send fs to host mirror
                    cmd = 'zfs send -R {inc} {zfs_main}/{fs}@{snap_name}|\
                           ssh {host_mirror} "zfs recv -u {zfs_main}/{fs}"'.format(
                        zfs_main=fs.zfs_main, fs=fs.name, host_mirror=fs.host_mirror,
                        inc=last_inc, snap_name=snap_name
                    )

                    async def async_zfs_send(cmd, snap_name, fs):
                        returncode = await self.cmd.call(
                            cmd, shell=True, run_async=True
                        )
                        if returncode == 0:
                            return Result(True, fs, snap_name)
                        return Result(False, fs, snap_name)
                    tasks.append(async_zfs_send(cmd, snap_name, fs))
                    if not host_mirros_up[fs.host_mirror]:
                        print("Mirror host is down, trying it next time")
            else:
                async def dummy():  # if we don't have a mirror
                    returncode = await self.cmd.call(
                        'true', shell=False, run_async=True
                    )
                    if self.args.test:
                        return Result(False, fs, snap_name)
                    else:
                        return Result(True, fs, snap_name)
                tasks.append(dummy())
        return tasks

    def inspect(self):
        print('# config ')
        print('managed_containers: %s' % ", ".join(self.fsmanager.managed_containers))
        print('managed_vms: %s' % ", ".join(self.fsmanager.managed_vms))
        print('managed_plain_items: %s' % ", ".join(self.fsmanager.managed_plain_items))
        print()
        self._update_running()

        if self.args.items:
            fs_to_inspect = self.fsmanager.all_to_fs(self.args.items)
        else:
            fs_to_inspect = self.running
            print('# running filesystems')

        for fs in fs_to_inspect:
            print(
                '''{fs.name}@{fs.kind} host_mirror:{fs.host_mirror} zfs_main:{fs.zfs_main}
- main fs:             {fs.main_fs}
- backup fs:           {fs.backup_fs}
- autosnap_from_file:  @{fs.autosnap_file}
- autosnap_zfs_local:  @{fs.autosnap_local}
- autosnap_zfs_mirror: @{fs.autosnap_mirror}
- backup_from_file:    @{fs.backup_file}'''.format(fs=fs)
            )
            if not fs.is_valid_autosnap():
                print("ERROR: autosnaps don't match")
            print()

    def _fs_mountpoint(self, fs):
        zfs_mountpoint = self.cmd.output(
            'zfs get -H -o value mountpoint %s' % fs.main_fs, split=False
        )
        return zfs_mountpoint

    async def _zmt_mirror_exec(self, zmt_cmd, fs):
        await self.cmd.call(
            'ssh {host_mirror} "{script_path} {zmt_cmd}"'.format(
                host_mirror=fs.host_mirror, script_path=self.zmt_path,
                zmt_cmd=zmt_cmd
            ), shell=True, run_async=True
        )

    async def _zfs_exec(self, zfs_cmd, fs, extra=""):
        await self.cmd.call(
            'zfs {zfs_cmd} {fs_main_fs}'.format(
                zfs_cmd=zfs_cmd, fs_main_fs=fs.main_fs, extra=extra
            ), run_async=True
        )

    async def _zfs_mirror_exec(self, zfs_cmd, fs, extra=""):
        await self.cmd.call(
            'ssh {host_mirror} "zfs {zfs_cmd} {fs_main_fs} {extra}"'.format(
                host_mirror=fs.host_mirror, zfs_cmd=zfs_cmd,
                fs_main_fs=fs.main_fs, extra=extra
            ), shell=True, run_async=True
        )

    def _update_running(self):
        self.running = []
        running_items = self.loop_run(asyncio.gather(
            *self._running_tasks()
        ))
        for running_item in running_items:
            self.running += running_item
        self.running += self.fsmanager.plain_items

    def _check_running(self):
        if not self.args.items and not self.running:
            print('No vms/containers running and no vm/container specified')
            exit(1)

    def activate(self):
        fs = self._item_to_fs()
        self._activate(fs)

    def _activate(self, fs):
        # write last autosnap from last zfs snaphost
        fs.write_snap_file('autosnap', fs.autosnap_local)

    def deactivate(self):
        fs = self._item_to_fs()
        self.loop_run(asyncio.wait([self._deactivate(fs)]))

    async def _deactivate(self, fs):
        if fs not in self.running:
            await self.cmd.call('rm -f %s' % fs.autosnap_file_path, run_async=True)
        else:
            print("container/vm is running, not deactivating")
            await asyncio.sleep(0)

    def _autosnap_fs(self):
        return self.fsmanager.all_to_fs(os.listdir('/var/lib/zmt/autosnap'))

    def mount(self):
        tasks = []
        for fs in self._all_autosnap_fs():
            tasks.append(fs.mount_task())
        self.loop_run(asyncio.wait(tasks))

    def umount(self):
        tasks = []
        for fs in self._all_autosnap_fs():
            tasks.append(fs.mount_task(cmd_zfs='zfs umount %s', reverse=True))
        self.loop_run(asyncio.wait(tasks))

    def start(self):
        async def async_pre_start(fs):
            cmd_pre_start = fs.options['start']
            returncode = await self.cmd.call(cmd_pre_start, run_async=True)

        pre_tasks = []
        for fs in self._all_autosnap_fs():
            if 'start' in fs.options:
                pre_tasks.append(async_pre_start(fs))
        if pre_tasks:
            self.loop_run(asyncio.wait(pre_tasks))

        async def async_start(fs):
            if fs.kind == 'container':
                await self._compose(fs, 'up -d', run_async=True)
            if fs.kind == 'vm':
                await self._virsh(fs, 'start', run_async=True)

        tasks = []
        for fs in self._all_autosnap_fs():
            tasks.append(async_start(fs))
        self.loop_run(asyncio.wait(tasks))

    def stop(self, all_fs=None):
        async def async_stop(fs):
            commands = {
                'container': {'stop': 'stop', 'kill': 'kill'},
                'vm': {'stop': 'shutdown', 'kill': 'destroy'},
            }
            cmd = commands[fs.kind][self.args.cmd_stop]
            if fs.kind == 'container':
                await self._compose(fs, cmd, run_async=True)
            if fs.kind == 'vm':
                await self._virsh(fs, cmd, run_async=True)

        def check_vm_stop_complete(all_fs):
            all_running_vms = set(self.cmd.output('virsh list --name'))
            all_vms_to_stop = set([fs.name for fs in all_fs if fs.kind == 'vm'])
            if len(all_vms_to_stop - all_running_vms) != len(all_vms_to_stop):
                time.sleep(0.5)
                check_vm_stop_complete(all_fs)

        async def async_post_stop(fs):
            cmd_post_stop = fs.options['stop']
            returncode = await self.cmd.call(cmd_post_stop, run_async=True)

        tasks = []
        fs_to_stop = all_fs or self._all_autosnap_fs()
        for fs in fs_to_stop:
            tasks.append(async_stop(fs))
        self.loop_run(asyncio.wait(tasks))
        check_vm_stop_complete(fs_to_stop)
        post_tasks = []
        for fs in fs_to_stop:
            if 'stop' in fs.options:
                post_tasks.append(async_post_stop(fs))
        if post_tasks:
            self.loop_run(asyncio.wait(post_tasks))
        self._update_running()

    def autostart(self):
        self.mount()
        self.start()

    async def _async_wait(self, all_fs, func, kwargs={}):
        tasks = []
        for fs in all_fs:
            new_tasks = func(fs, **kwargs)
            if not isinstance(new_tasks, (list, tuple)):
                new_tasks = [new_tasks]
            tasks = tasks + new_tasks
        return await asyncio.wait(tasks)

    def move(self):
        snap_name = self._create_autosnap_name()

        async def async_check_autosnap(fs):
            await self._zfs_mirror_exec('get -H -o value mounted', fs, extra='|grep -q no')
            last_inc = fs.autosnap_file
            try:
                await self._zfs_mirror_exec(
                    'list -H -o name -r -d 1 -t snap', fs, extra='|grep -q %s' % last_inc
                )
            except subprocess.CalledProcessError:
                print("""stopping move, the previous autosnap (%s) \
does't exists on the target remote filesystem""" % last_inc)
                exit(1)

        async def async_check_in_use(fs):
            try:
                # check for open files/dirs, would break unmount
                await self.cmd.call(
                    '! lsof -X -w|grep -q /%s/%s' % (fs.zfs_main, fs.name),
                    shell=True, run_async=True, check_returncode=False
                )
            except subprocess.CalledProcessError:
                print("stopping move, the directory /%s/%s is in use" % (fs.zfs_main, fs.name))
                exit(1)

        def async_mount_cleanup(fs):
            tasks = []

            async def async_umount(fs):
                await fs.mount_task(cmd_zfs='zfs umount %s', reverse=True)
            tasks.append(async_umount(fs))

            async def async_mirror_mount(fs):
                await self._zmt_mirror_exec('mount %s' % fs.name, fs)
            tasks.append(async_mirror_mount(fs))

            async def async_deactivate(fs):
                await self._deactivate(fs)
            tasks.append(async_deactivate(fs))

            return tasks

        async def async_send_cleanup(fs):
            if fs.kind == 'container':
                await self._compose(fs, 'rm -f', run_async=True)
            else:
                await asyncio.sleep(0)

        def async_activate_start(fs):
            tasks = []

            async def async_activate_mirror(fs):
                await self._zmt_mirror_exec("activate %s" % fs.longname, fs)
            tasks.append(async_activate_mirror(fs))

            async def async_start(fs):
                await self._zmt_mirror_exec("start %s" % fs.longname, fs)
            tasks.append(async_start(fs))
            return tasks

        self._update_running()

        if self.args.item:
            fs = self._item_to_fs()
            if fs not in self.running:
                print('The filesystem must be in use for automatic moving')
                exit(1)
            all_fs = [fs]
        else:
            all_fs = self.running
            if self.args.kind:
                all_fs = [fs for fs in all_fs if fs.kind == self.args.kind]
            if not all_fs:
                print('No running container/vm found')
                exit(1)

        self._create_lock('autosnap')
        self.loop_run(self._async_wait(all_fs, async_check_autosnap))
        self.stop(all_fs)
        self.loop_run(self._async_wait(all_fs, async_check_in_use))
        self.loop_run(self._async_wait(all_fs, async_send_cleanup))
        for fs_chunk in split_list(all_fs, MAX_AUTOSNAP_NR):
            self.loop_run(self._async_wait(fs_chunk, self._autosnap, dict(snap_name=snap_name)))
            tasks_results = self.loop_run(asyncio.gather(
                *self._autosnap_send(fs_chunk, snap_name))
            )
            for task in tasks_results:
                if task.has_run:
                    task.fs.write_snap_file('autosnap', task.snap_name)
                else:
                    msg = "autosnap for fs: %(fs)s, with snap_name: %(snap_name)s, failed"
                    print(msg % task._asdict())
        self.loop_run(self._async_wait(all_fs, async_mount_cleanup))
        self.loop_run(self._async_wait(all_fs, async_activate_start))
        self._remove_lock('autosnap')

    async def _compose(self, fs, compose_cmd="stop", run_async=False):
        if fs.kind == 'container':
            if 'compose_file' in self.config['container']:
                compose_file = self.config['container']['compose_file']
            else:
                compose_file = 'docker-compose.yml'
            zfs_mountpoint = self._fs_mountpoint(fs)
            await self.cmd.call(
                'docker-compose -f %s %s' % (compose_file, compose_cmd),
                cwd=zfs_mountpoint, run_async=run_async
            )

    async def _virsh(self, fs, virsh_cmd="start", run_async=False):
        if fs.kind == 'vm':
            await self.cmd.call('virsh %s %s' % (virsh_cmd, fs.name), run_async=run_async)

    def _backup_snap_names(self, snap_names):
        backup_snap_names = OrderedDict()
        for snap_fullname in snap_names:
            snap_root, snap_name = snap_fullname.split("@")
            if (self.args.backup_snap_name and snap_name == self.args.backup_snap_name) \
               or not self.args.backup_snap_name:
                if snap_root not in backup_snap_names:
                    backup_snap_names[snap_root] = snap_name
        return backup_snap_names

    def _offsite_snap_names(self, snap_names, src_host):
        offsite_snap_names = OrderedDict()
        for snap_fullname in snap_names:
            snap_root, snap_name = snap_fullname.split("@")
            snap_src_root = snap_root
            if snap_src_root not in offsite_snap_names:
                offsite_snap_names[snap_src_root] = snap_name
        return offsite_snap_names

    def is_dest_not_changed(self, snap_dest_root, last_inc, dest_host=None):
        _, _, snap_name = last_inc.partition('@')
        if snap_name:
            cmd_is_mounted, cmd_mount, cmd_diff = self._add_ssh_if_host(
                'zfs get -H -o value mounted {}'.format(snap_dest_root),
                'zfs mount {}'.format(snap_dest_root),
                'zfs diff -H {}@{}'.format(snap_dest_root, snap_name),
                host=dest_host
            )
            try:
                is_mounted = self.cmd.output(cmd_is_mounted, shell=True) == ['yes']
                if not is_mounted:
                    self.cmd.call(cmd_mount, shell=True)
                if self.cmd.output(cmd_diff, shell=True) == []:
                    return True
                else:
                    return False
            except subprocess.CalledProcessError:
                print("someting went wrong with {}".format(cmd_diff))
                exit(1)
        return True

    def _src_snap_names(self, fs, fs_src, last_inc, src_host=None):
        if src_host:
            cmd = 'ssh {src_host} "zfs list -H -S creation -r -o name -t snap {zfs_src_root}/{fs}"'.format(
                src_host=src_host, zfs_src_root=getattr(fs, "zfs_%s" % fs_src),
                fs=fs.name, inc=last_inc
            )
            src_snap_names = self.cmd.output(cmd, shell=True)
        else:
            cmd = 'zfs list -H -S creation -r -o name -t snap {zfs_src_root}/{fs}'.format(
                zfs_src_root=getattr(fs, "zfs_%s" % fs_src), fs=fs.name, inc=last_inc
            )
            src_snap_names = self.cmd.output(cmd)
        return src_snap_names

    def _add_ssh_if_host(self, *args, host=None):
        if not host:
            if len(args) == 1:
                return args[0]
            return args
        commands = []
        for cmd in args:
            commands.append('ssh {} "{}"'.format(host, cmd))
        if len(commands) == 1:
            return commands[0]
        return commands

    def _zfs_send_receive(self, fs, snap_type='backup', fs_src='main',
                          src_host=None, dest_host=None, dest_replace=None):
        failures = ''
        try:
            inc_as_stream = True if snap_type == 'offsite' else False
            last_inc = fs.inc_from_file(snap_type=snap_type, inc_as_stream=inc_as_stream)
            src_snap_names = self._src_snap_names(fs, fs_src, last_inc, src_host=src_host)

            if snap_type == 'backup':
                src_snap_dict = self._backup_snap_names(src_snap_names)
            if snap_type == 'offsite':
                src_snap_dict = self._offsite_snap_names(src_snap_names, src_host)
            transfer_done = False

            search_and_replace = {
                'backup': lambda: [fs.zfs_main, fs.zfs_backup],
                'offsite': lambda: dest_replace.split('|')
            }[snap_type]()
            # send only the newest snapshot from src to dest
            for snap_src_root, snap_name in src_snap_dict.items():
                if (last_inc and not last_inc.split('@')[1] in snap_name) or (not last_inc):
                    Parameters = namedtuple(
                        'Parameters', 'snap_src_root, snap_dest_root, snap_name, last_inc, src_host'
                    )
                    snap_dest_root = snap_src_root.replace(*search_and_replace)
                    parameters = Parameters(
                        snap_src_root, snap_dest_root, snap_name, last_inc, src_host
                    )
                    if self.is_dest_not_changed(parameters.snap_dest_root, parameters.last_inc, dest_host=dest_host):
                        zfs_send = self._add_ssh_if_host(
                            'zfs send {last_inc} {snap_src_root}@{snap_name}'.format(**parameters._asdict()),
                            host=src_host
                        )
                        zfs_recv = self._add_ssh_if_host(
                            'zfs recv -u {snap_dest_root}'.format(**parameters._asdict()),
                            host=dest_host
                        )
                        if self.args.test or self.args.verbose:
                            print('{}|{}'.format(zfs_send, zfs_recv).replace('   ', ''))
                        if not self.args.test:
                            if fs.backup_file:
                                zfs_readonly = self._add_ssh_if_host(
                                    'zfs set readonly=on {}'.format(parameters.snap_dest_root),
                                    host=dest_host
                                )
                                self.cmd.call(zfs_readonly, shell=True)
                            self.cmd.call('{}|{}'.format(zfs_send, zfs_recv), shell=True)
                            transfer_done = True
                    else:
                        transfer_done = False
                        _, _, snap_name = last_inc.partition('@')
                        print("can't receive snapshot destination was changed please rollback {}@{}".format(
                            parameters.snap_dest_root, snap_name
                        ))
                else:
                    if snap_type == 'backup':
                        print("no newer snapshot to backup for %s" % snap_src_root)

            if transfer_done:
                fs.write_snap_file(snap_type, src_snap_dict[getattr(fs, "%s_fs" % fs_src)])

        except:
            failures += traceback.format_exc()
        return failures

    def backup(self):
        if not os.path.exists('/var/lib/zmt/backup/'):
            os.makedirs('/var/lib/zmt/backup/')

        if self.args.items:
            fs_to_backup = self.fsmanager.all_to_fs(self.args.items)
        else:
            # proccess all managed fs from zmt.ini
            fs_to_backup = self.fsmanager.fs
        failures = ''
        self._create_lock('backup')
        for fs in fs_to_backup:
            failures += self._zfs_send_receive(
                fs, snap_type='backup', fs_src='main', dest_host=fs.zfs_backup_host
            )
        if failures:
            print(failures)
            sys.exit(1)
        self._remove_lock('backup')

    def _list_snaps(self, zfs_root, fs_name):
        cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs_root}/{fs_name}|'
        cmd = (cmd + 'grep "@autosnap-"').format(zfs_root=zfs_root, fs_name=fs_name)
        snaps = self.cmd.output(cmd, shell=True)
        return snaps

    def _destroy_snaps(self, snaps, snaps_keep):
        verbose, dry_run = self.args.verbose, self.args.dry_run
        for snap in snaps[snaps_keep:]:
            cmd = 'zfs destroy{verbose}{dry_run} -r {snap}'.format(
                verbose=verbose, dry_run=dry_run, snap=snap
            )
            snap_exitcode, snap_output = subprocess.getstatusoutput(cmd)
            if verbose:
                print(snap_output)

    def _create_autosnap_name(self):
        now_string = self.cmd.output(AUTOSNAP_DATECMD, shell=False)[0]
        date_time, tz, tz_shift = now_string.partition('TZ')
        snap_name = "autosnap-%s%s%s" % (date_time, tz, tz_shift.replace('+', 'p').replace('-', 'm'))
        return snap_name

    def cleanup(self):
        for fs in self.fsmanager.fs:
            # normal backup snaps
            backupsnaps = self._list_snaps(fs.zfs_backup, fs.name)
            if len(backupsnaps) > fs.backupsnaps_keep:
                self._destroy_snaps(backupsnaps, fs.backupsnaps_keep)

            # normal autosnaps
            if self.args.tank_destroy:
                autosnaps = self._list_snaps(fs.zfs_main, fs.name)
                newest_backupsnap = backupsnaps[0].partition('@')[-1]
                keep_autosnaps = [s.partition('@')[-1] for s in autosnaps[:fs.autosnaps_keep]]
                if len(autosnaps) > fs.autosnaps_keep:
                    if newest_backupsnap in keep_autosnaps:
                        self._destroy_snaps(autosnaps, fs.autosnaps_keep)
                    else:
                        raise RuntimeError(
                            "The cleanup would disconnect the filesystem '%s' from backup (%s)" % (
                                fs.name, newest_backupsnap
                            )
                        )

        # rsync backup snaps
        if self.config.has_section('rsync_items'):
            for fs_name, host_src in self.config.items('rsync_items'):
                backupsnaps = self._list_snaps(self.config['rsync']['zfs_backup'], fs_name)
                backupsnaps_keep = int(get_config_value(
                    self.config, 'backupsnaps_keep', section='rsync', fs_name=fs_name)
                )
                if len(backupsnaps) > backupsnaps_keep:
                    self._destroy_snaps(backupsnaps, backupsnaps_keep)

    def rsync(self):
        if self.args.host:
            rsync_items = [(
                self.args.host, self.config['rsync_items'][self.args.host]
            )]
        else:
            rsync_items = self.config.items('rsync_items')
        snap_name = self._create_autosnap_name()
        verbose, dry_run = self.args.verbose, self.args.dry_run

        failures = ''
        for fs, host_src in rsync_items:
            current_failure_tries = 3

            def create_rsync_cmd(host_src):
                dest = '%s/%s' % (self.config['rsync']['dest_path'], fs)
                dest = dest if '/' == dest[:-1] else "%s/" % dest
                excludes = [
                    '--exclude=%s' % exclude
                    for exclude in self.config['rsync']['excludes'].split(',')
                ]

                excludes.insert(0, '')  # space between options
                host_src, delimiter, extra_options = host_src.partition('|')
                if extra_options:
                    extra_options = extra_options.split('|')
                    extra_options.insert(0, '')  # space between options
                cmd = 'rsync {dry_run}{verbose}{options}{excludes}{extra_options} {host_src} {dest}'
                cmd = cmd.format(
                    dry_run=dry_run, verbose=verbose, options=self.config['rsync']['cmd_options'],
                    excludes=' '.join(excludes), extra_options=' '.join(extra_options),
                    host_src=host_src, dest=dest
                )
                # extract hostname
                host_name = host_src.split(':')[0].split('@')[-1]
                if verbose:
                    print("* syncing host:%s" % host_name)
                    print("* with command:\n%s\n" % cmd)
                return (cmd, host_name)

            cmd, host_name = create_rsync_cmd(host_src)
            if self._host_is_up(host_name):
                def exec_rsync_cmd(failures, current_failure_tries, cmd):
                    if current_failure_tries > 1:
                        try:
                            self.cmd.call(cmd)
                            snap_cmd = 'zfs snap -r {zfs_backup}/{fs}@{name}'.format(
                                zfs_backup=self.config['rsync']['zfs_backup'],
                                fs=fs, name=snap_name
                            )
                            if verbose:
                                print("* zfs snap rsync with command:\n  %s" % snap_cmd)
                            if dry_run:
                                print("* zfs snap rsync not done, in dry-run mode")
                            else:
                                self.cmd.call(snap_cmd)
                        except:
                            failures += traceback.format_exc()
                            current_failure_tries -= 1
                            failures = exec_rsync_cmd(failures, current_failure_tries, cmd)
                    return failures
                failures = exec_rsync_cmd(failures, current_failure_tries, cmd)
            else:
                print("The host %s is down." % host_name)
        if failures:
            print(failures)
            sys.exit(1)

    def scripts(self):
        if self.config.has_section('scripts_items'):
            if self.args.item:
                scripts_items = [(
                    self.args.item, self.config['scripts_items'][self.args.item]
                )]
            else:
                scripts_items = self.config.items('scripts_items')
            verbose, dry_run = self.args.verbose, self.args.dry_run
            snap_name = self._create_autosnap_name()
            outputs = []
            for fs, script_cmd in scripts_items:
                working_dir = self.cmd.output('zfs get mountpoint -o value -H {zfs_backup}/{fs}'.format(
                    zfs_backup=self.config['scripts']['zfs_backup'], fs=fs
                ), split=False)
                output = self.cmd.output(script_cmd, cwd=working_dir)
                if output:
                    outputs.append("\n\n%s:%s\n%s" % (fs, script_cmd, output))
                snap_cmd = 'zfs snap -r {zfs_backup}/{fs}@{name}'.format(
                    zfs_backup=self.config['scripts']['zfs_backup'],
                    fs=fs, name=snap_name
                )
                if verbose:
                    print("* executing script:\n  %s" % script_cmd)
                if dry_run:
                    print("* zfs snap not done, in dry-run mode")
                else:
                    self.cmd.call(snap_cmd)
            if outputs:
                print("\n".join(outputs))

    def offsite(self):
        if self.config.has_section('offsite_items'):
            if not os.path.exists('/var/lib/zmt/offsite/'):
                os.makedirs('/var/lib/zmt/offsite/')
            self._create_lock('offsite')
            self.offsite_processed_fs = []
            for entry in self.config.items('offsite_items'):
                host, dest_replace = entry
                offsite_config = configparser.ConfigParser()
                offsite_config.read_string(
                    self.cmd.output('ssh %s cat /etc/zmt/zmt.ini' % host, split=False)
                )
                self._offsite_single_host(host, offsite_config, dest_replace=dest_replace)
            self._remove_lock('offsite')

    def _offsite_single_host(self, host, offsite_config, dest_replace=None):
        failures = ''
        fsmanager = FilesystemManager(config=offsite_config, kind=self.args.kind)
        for fs in fsmanager.fs_backup:
            if fs.longname not in self.offsite_processed_fs:
                failures += self._zfs_send_receive(
                    fs, snap_type='offsite', fs_src='backup',
                    src_host=host, dest_replace=dest_replace
                )
                self.offsite_processed_fs.append(fs.longname)
        if failures:
            print(failures)


class ZfsParser:
    def __init__(self):
        self.parser = argparse.ArgumentParser(
            description="""zfs management tools,
                           for snapshoting, replication, backup""")
        self.subparsers = self.parser.add_subparsers(
            help='avaiable commands')
        for (fname, func) in inspect.getmembers(self, predicate=inspect.ismethod):
            if fname.startswith('parser_'):
                func(self.subparsers)

        self.config = configparser.ConfigParser()
        self.config.read('/etc/zmt/zmt.ini')

    def run(self):
        args = self.parser.parse_args()
        if not hasattr(args, 'command'):
            self.parser.print_help()
            exit(0)
        self.zfstools = ZfsTools(args, self.config)

        if hasattr(self.zfstools, args.command):
            getattr(self.zfstools, args.command)()
        else:
            print('command %s not known' % args.command)

    def close(self):
        self.zfstools.close()

    def parser_autosnap(self, subparsers):
        parser = self.subparsers.add_parser(
            'autosnap',
            help='create a snapshot'
        )
        parser.add_argument(
            '-t', '--test', dest='test', action='store_true',
            default=False, help='only show zfs commands and exit'
        )
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument('items', nargs='*', default=None)
        parser.set_defaults(command='autosnap')

    def parser_activate(self, subparsers):
        parser = self.subparsers.add_parser(
            'activate',
            help='write latest autosnap to /var/lib/zmt/autosnap'
        )
        parser.add_argument('item', nargs=1)
        parser.set_defaults(command='activate')

    def parser_deactivate(self, subparsers):
        parser = self.subparsers.add_parser(
            'deactivate',
            help='remote latest autosnap file from /var/lib/zmt/autosnap'
        )
        parser.add_argument('item', nargs=1)
        parser.set_defaults(command='deactivate')

    def parser_move(self, subparsers):
        parser = self.subparsers.add_parser(
            'move',
            help='move item to host mirror'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument moves all container/vms"
        )
        parser.add_argument(
            '--kill', dest='cmd_stop', action='store_const', const='kill',
            default='stop', help='use kill instead of stop for shutdown'
        )
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            '--container', dest='kind', action='store_const', const='container',
            default='', help='only move containers'
        )
        group.add_argument(
            '--vm', dest='kind', action='store_const', const='vm',
            default='', help='only move vms (not implemented yet)'
        )
        parser.set_defaults(command='move')

    def parser_start(self, subparsers):
        parser = self.subparsers.add_parser(
            'start',
            help='start one or all container/or vm'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument starts all container/vms"
        )
        parser.set_defaults(command='start')

    def parser_autostart(self, subparsers):
        parser = self.subparsers.add_parser(
            'autostart',
            help='mount and start all activated containers/vms'
        )
        parser.set_defaults(command='autostart')

    def parser_stop(self, subparsers):
        parser = self.subparsers.add_parser(
            'stop',
            help='stop container/or vm'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument stops all container/vms"
        )
        parser.add_argument(
            '--kill', dest='cmd_stop', action='store_const', const='kill',
            default='stop', help='use kill instead of stop for shutdown'
        )
        parser.set_defaults(command='stop')

    def parser_backup(self, subparsers):
        parser = self.subparsers.add_parser(
            'backup',
            help='create a backup'
        )
        parser.add_argument(
            '-t', '--test', dest='test', action='store_true',
            default=False, help='only show zfs commands and exit'
        )
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-s', '--snap-name', dest='backup_snap_name', action='store',
            default='', help=''
        )
        parser.add_argument('items', nargs='*', default=None)
        parser.set_defaults(command='backup')

    def parser_cleanup(self, subparsers):
        parser = self.subparsers.add_parser(
            'cleanup',
            help='only keep the N recent snapshots'
        )
        parser.add_argument(
            '-v', dest='verbose', const=' -v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-n', dest='dry_run', const=' -n ', action='store_const',
            default='', help='dry-run'
        )
        parser.add_argument(
            '--no-tank-destroy', dest='tank_destroy', action='store_false',
            default=True, help="only delete backup snapshos, don't touch tank"
        )
        parser.set_defaults(command='cleanup')

    def parser_rsync(self, subparsers):
        parser = self.subparsers.add_parser(
            'rsync',
            help='make rsync backups with snapshots'
        )
        parser.add_argument('host', nargs='?', default=None)
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-n', dest='dry_run', const='-n ', action='store_const',
            default='', help='dry-run, no snapshots'
        )
        parser.set_defaults(command='rsync')

    def parser_mount(self, subparsers):
        parser = self.subparsers.add_parser(
            'mount',
            help='mount active filesystems on host'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument mounts all container/vms"
        )
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.set_defaults(command='mount')

    def parser_umount(self, subparsers):
        parser = self.subparsers.add_parser(
            'umount',
            help='umount active filesystems on host'
        )
        parser.add_argument(
            'item', nargs='?', default=None,
            help="without argument unmounts all container/vms"
        )
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.set_defaults(command='umount')

    def parser_scripts(self, subparsers):
        parser = self.subparsers.add_parser(
            'scripts',
            help='execute a script and make afterwards a snapshot'
        )
        parser.add_argument('item', nargs='?', default=None)
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-n', dest='dry_run', const='-n ', action='store_const',
            default='', help='dry-run, only execute script(s) no snapshot'
        )
        parser.set_defaults(command='scripts')

    def parser_offsite(self, subparsers):
        parser = self.subparsers.add_parser(
            'offsite',
            help='save all backup snapshots to an offsite location'
        )
        parser.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser.add_argument(
            '-t', '--test', dest='test', action='store_true',
            default=False, help='only show zfs commands and exit'
        )
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            '--container', dest='kind', action='store_const', const='container',
            default='all', help='only get container filesystems'
        )
        group.add_argument(
            '--vm', dest='kind', action='store_const', const='vm',
            default='all', help='only get vm filesystems'
        )
        group.add_argument(
            '--rsync', dest='kind', action='store_const', const='rsync',
            default='all', help='only get rsync filesystems'
        )
        group.add_argument(
            '--scripts', dest='kind', action='store_const', const='scripts',
            default='all', help='only get scripts filesystems'
        )
        parser.set_defaults(command='offsite')

    def parser_inspect(self, subparsers):
        parser = self.subparsers.add_parser(
            'inspect',
            help='compare autosnap version of current host and mirror host'
        )
        parser.add_argument('items', nargs='*', default=None)
        parser.set_defaults(command='inspect')


def main():
    # main parser
    zfs_parser = ZfsParser()
    zfs_parser.run()
    zfs_parser.close()


if __name__ == '__main__':
    main()
