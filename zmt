#!/usr/bin/env python3
# coding: utf-8

import argparse
import subprocess
import configparser
import os
from datetime import datetime

AUTOSNAP_DATESTR = '%Y-%m-%d_%H:%M:%S'


class ZfsTools:
    def __init__(self, args, config):
        self.args = args
        self.config = config
        self.running_vms = self._get_running_vms()

    def _get_running_vms(self):
        running_vms = subprocess.check_output(
            'virsh list --name',
            universal_newlines=True, shell=True
        ).splitlines()
        managed_vms = self.config['vm']['managed'].split(',')
        running_vms = [vm for vm in running_vms if vm and vm in managed_vms]
        return running_vms

    def _get_inc_from_file(self, snap_fname, inc_as_stream=False):
        snap_fname = '/var/lib/zmt/%s' % snap_fname
        inc = ''
        if os.path.exists(snap_fname):
            with open(snap_fname) as last_snap_f:
                last_snap = last_snap_f.read().strip()
                inc = ('-I @%s' if inc_as_stream else '-i @%s') % last_snap
        return inc

    def _get_last_snap_from_zfs(self, fs):
        # get all snapshots from tank
        cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs}/{fs}'.format(
            fs=fs, zfs=self.config['vm']['zfs']
        )
        snap_names = subprocess.check_output(
            cmd, universal_newlines=True, shell=True
        ).splitlines()
        if snap_names[0] and '@autosnap-' in snap_names[0]:
            return ''.join(snap_names[0].partition("@autosnap-")[1:])[1:]
        else:
            print("the last snapshot needs to be a autosnap snapshot from zmt")
            exit(1)

    def _write_snap_file(self, snap_fname, snap_name):
        snap_fname = '/var/lib/zmt/%s' % snap_fname
        with open(snap_fname, 'w') as last_snap:
            last_snap.write(snap_name)

    def _get_snap_name(self, fq_snap_name):
        return fq_snap_name.split('@')[1]

    def _host_is_up(self, host):
        # check if host mirror is reachable
        cmd = 'ping -O -c 1 %s' % host
        ping_exitcode, ping_output = subprocess.getstatusoutput(cmd)
        if ping_exitcode == 0:
            return True
        else:
            return False

    def autosnap(self):
        if not self.running_vms and not self.args.vm:
            print('No vms running and no vm specified')
            exit(0)

        if self.args.vm:
            fs_to_snap = [self.args.vm]
        else:
            fs_to_snap = self.running_vms
        if not os.path.exists('/var/lib/zmt/autosnap/'):
            os.makedirs('/var/lib/zmt/autosnap/')
        now_string = datetime.now().strftime(AUTOSNAP_DATESTR)

        # metadata for the snapshot
        snap_conf = {
            'zfs': self.config['vm']['zfs'],
            'name': 'autosnap-%s' % now_string,
            'host_mirror': self.config['vm']['host_mirror'],
        }

        # create the local snapshots
        for fs in fs_to_snap:
            # snap it
            cmd = 'zfs snap -r {zfs}/{fs}@{name}'.format(fs=fs, **snap_conf)
            subprocess.check_call(cmd, universal_newlines=True, shell=True)

        if self._host_is_up(snap_conf['host_mirror']):
            # send all snapshots over ssh to the host_mirror
            for fs in fs_to_snap:
                last_inc = self._get_inc_from_file(
                    'autosnap/%s' % fs, inc_as_stream=True
                )
                # send fs to host mirror
                cmd = 'zfs send -R {inc} {zfs}/{fs}@{name} | ssh {host_mirror} "zfs recv {zfs}/{fs}"'.format(fs=fs, inc=last_inc, **snap_conf)
                subprocess.check_output(
                    cmd, universal_newlines=True, shell=True
                )

                # write last autosnap
                self._write_snap_file(
                    'autosnap/%s' % fs, snap_conf['name']
                )
        else:
            print("Mirror host is down, trying it next time")

    def moved(self):
        if not self.args.vm:
            print('No vm specified')
            exit(0)
        else:
            fs = self.args.vm[0]

        # write last autosnap from last zfs snaphost
        self._write_snap_file(
            'autosnap/%s' % fs, self._get_last_snap_from_zfs(fs)
        )

    def backup(self):
        if not os.path.exists('/var/lib/zmt/backup/'):
            os.makedirs('/var/lib/zmt/backup/')

        # metadata for the snapshot
        snap_conf = {
            'zfs': self.config['vm']['zfs'],
            'backup': self.config['vm']['backup']
        }

        # proccess all managed vms from zmt.ini
        for fs in self.config['vm']['managed'].split(','):
            fs = fs.strip()
            last_inc = self._get_inc_from_file(
                'backup/%s' % fs, inc_as_stream=False
            )

            # get all snapshots from tank
            cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs}/{fs}'.format(fs=fs, inc=last_inc, **snap_conf)
            snap_names = subprocess.check_output(
                cmd, universal_newlines=True, shell=True
            ).splitlines()

            backup_snap_names = []
            for snap_name in snap_names:
                if "@autosnap-" in snap_name:
                    backup_snap_names.append(snap_name)
                    break
                else:
                    backup_snap_names.append(snap_name)
            backup_snap_names.reverse()
            backup_done = False

            # send the only the newest snapshot from tank to backup
            for snap_name in backup_snap_names:
                if (last_inc and not last_inc.split('@')[1] in snap_name) or (not last_inc):
                    cmd = 'zfs send -R {last_inc} {snap_name} | zfs recv -Fu {backup}/{fs}'.format(
                        fs=fs, last_inc=last_inc,
                        snap_name=snap_name, **snap_conf
                    )
                    subprocess.check_output(
                        cmd, universal_newlines=True, shell=True
                    )
                    backup_done = True
                    last_inc = '-i @%s' % self._get_snap_name(snap_name)
                else:
                    print("no newer snapshot to backup")

            if backup_done:
                # write last backupsnap
                self._write_snap_file(
                    'backup/%s' % fs,
                    self._get_snap_name(backup_snap_names[-1])
                )

                # fix mountpoints
                cmd = 'zfs set mountpoint=/{backup}/{fs} {backup}/{fs}'.format(fs=fs, **snap_conf)
                subprocess.check_output(
                    cmd, universal_newlines=True, shell=True
                )

    def cleanup(self):
        autosnap_keep = int(self.config['autosnap']['keep'])
        for fs in self.config['vm']['managed'].split(','):
            fs = fs.strip()
            cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs}/{fs} | grep "@autosnap-"'.format(
                zfs=self.config['vm']['zfs'], fs=fs
            )
            snaps = subprocess.check_output(
                cmd, universal_newlines=True, shell=True
            ).splitlines()
            if len(snaps) > autosnap_keep:
                for snap in snaps[autosnap_keep:]:
                    cmd = 'zfs destroy -r %s' % snap
                    snap_exitcode, snap_output = subprocess.getstatusoutput(cmd)

    def rsync(self):
        if self.args.host:
            rsync_hosts = [(
                self.args.host, self.config['rsync_hosts'][self.args.host]
            )]
        else:
            rsync_hosts = self.config.items('rsync_hosts')
        now_string = datetime.now().strftime(AUTOSNAP_DATESTR)
        verbose, dry_run = self.args.verbose, self.args.dry_run
        for fs, host_src in rsync_hosts:
            dest = '%s/%s' % (self.config['rsync']['dest_path'], fs)
            dest = dest if '/' == dest[:-1] else "%s/" % dest
            excludes = ['--exclude=%s' % exclude for exclude in self.config['rsync']['excludes'].split(',')]
            cmd = 'rsync {dry_run}{verbose}{options} {excludes} {host_src} {dest}'.format(
                dry_run=dry_run,
                verbose=verbose,
                options=self.config['rsync']['cmd_options'],
                excludes=' '.join(excludes),
                host_src=host_src,
                dest=dest
            )
            # extract hostname
            host_name = host_src.split(':')[0].split('@')[-1]
            if self._host_is_up(host_name):
                subprocess.check_call(
                    cmd.split(' '), universal_newlines=True
                )
                if not dry_run:
                    # metadata for the snapshot
                    snap_conf = {
                        'zfs': self.config['rsync']['zfs'],
                        'name': 'autosnap-%s' % now_string
                    }
                    cmd = 'zfs snap -r {zfs}/{fs}@{name}'.format(fs=fs, **snap_conf)
                    subprocess.check_call(cmd, shell=True)
            else:
                print("The host %s is down." % host_name)


class ZfsParser:
    def __init__(self):
        self.parser = argparse.ArgumentParser(
            description="""zfs management tools,
                           for snapshoting, replication, backup""")
        self.subparsers = self.parser.add_subparsers(
            help='avaiable commands')
        self.parser_autosnap(self.subparsers)
        self.parser_moved(self.subparsers)
        self.parser_backup(self.subparsers)
        self.parser_cleanup(self.subparsers)
        self.parser_rsync(self.subparsers)
        self.config = configparser.ConfigParser()
        self.config.read('/etc/zmt/zmt.ini')

    def run(self):
        args = self.parser.parse_args()
        if not hasattr(args, 'command'):
            self.parser.print_help()
            exit(0)
        zfstools = ZfsTools(args, self.config)

        if hasattr(zfstools, args.command):
            getattr(zfstools, args.command)()
        else:
            print('command %s not known' % args.command)

    def parser_autosnap(self, subparsers):
        parser_autosnap = self.subparsers.add_parser(
            'autosnap',
            help='create a snapshot'
        )
        parser_autosnap.add_argument('vm', nargs='?', default=None)
        parser_autosnap.set_defaults(command='autosnap')

    def parser_moved(self, subparsers):
        parser_moved = self.subparsers.add_parser(
            'moved',
            help='set autosnap file to last snapshot'
        )
        parser_moved.add_argument('vm', nargs=1)
        parser_moved.set_defaults(command='moved')

    def parser_backup(self, subparsers):
        parser_backup = self.subparsers.add_parser(
            'backup',
            help='create a backup'
        )
        parser_backup.set_defaults(command='backup')

    def parser_cleanup(self, subparsers):
        parser_cleanup = self.subparsers.add_parser(
            'cleanup',
            help='only keep the N recent snapshots'
        )
        parser_cleanup.set_defaults(command='cleanup')

    def parser_rsync(self, subparsers):
        parser_rsync = self.subparsers.add_parser(
            'rsync',
            help='only keep the N recent snapshots'
        )
        parser_rsync.add_argument('host', nargs='?', default=None)
        parser_rsync.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser_rsync.add_argument(
            '-n', dest='dry_run',  const='-n ', action='store_const',
            default='', help='dry-run'
        )
        parser_rsync.set_defaults(command='rsync')


def main():
    # main parser
    zfs_parser = ZfsParser()
    zfs_parser.run()


if __name__ == '__main__':
    main()
