#!/usr/bin/env python3
# coding: utf-8

import argparse
import subprocess
import configparser
import os
from datetime import datetime

AUTOSNAP_DATESTR = '%Y-%m-%d_%H:%M:%S'


class Filesystem:
    def __init__(self, name, kind='vm', config=None):
        self.name = name.strip()
        self.kind = kind
        self.zfs_main = config[kind]['zfs_main']
        self.zfs_backup = None
        if 'zfs_backup' in config[kind]:
            self.zfs_backup = config[kind]['zfs_backup']
        self.host_mirror = None
        if 'host_mirror' in config[kind]:
            self.host_mirror = config[kind]['host_mirror']

    @property
    def longname(self):
        return "%s@%s" % (self.name, self.kind)

    def __str__(self):
        return self.longname


class ZfsTools:
    def __init__(self, args, config):
        self.args = args
        self.config = config
        self.running = []
        self.managed_containers, self.managed_vms = [], []
        if 'container' in self.config:
            self.managed_containers = self.config['container']['managed'].split(',')
        if 'vm' in self.config:
            self.managed_vms = self.config['vm']['managed'].split(',')
        self.managed_fs = (
            self._to_filesystem(self.managed_vms) +
            self._to_filesystem(self.managed_containers)
        )
        self.running = self._get_running_vms() + self._get_running_containers()

    def _make_running_list(self, items, managed_items, kind='vm'):
        running_items = [
            Filesystem(item, kind, self.config)
            for item in items
            if item and item in managed_items
        ]
        return running_items

    def _get_running_vms(self):
        running_vms = subprocess.check_output(
            'virsh list --name',
            universal_newlines=True, shell=True
        ).splitlines()
        return self._make_running_list(
            running_vms, self.managed_vms, kind='vm'
        )

    def _get_running_containers(self):
        running_containers = subprocess.check_output(
            'docker ps -q|xargs docker inspect --format "{{.Name}}"|\
             grep -oP "[a-z]*(?=_.*)"|uniq',
            universal_newlines=True, shell=True
        ).splitlines()
        return self._make_running_list(
            running_containers, self.managed_containers, kind='container'
        )

    def _get_inc_from_file(self, snap_fname, inc_as_stream=False):
        snap_fname = '/var/lib/zmt/%s' % snap_fname
        inc = ''
        if os.path.exists(snap_fname):
            with open(snap_fname) as last_snap_f:
                last_snap = last_snap_f.read().strip()
                inc = ('-I @%s' if inc_as_stream else '-i @%s') % last_snap
        return inc

    def _get_last_snap_from_zfs(self, fs):
        # get all snapshots from tank
        cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs}/{fs}'.format(
            fs=fs.name, zfs_main=self.config['vm']['zfs_main']
        )
        snap_names = subprocess.check_output(
            cmd, universal_newlines=True, shell=True
        ).splitlines()
        if snap_names[0] and '@autosnap-' in snap_names[0]:
            return ''.join(snap_names[0].partition("@autosnap-")[1:])[1:]
        else:
            print("the last snapshot needs to be a autosnap snapshot from zmt")
            exit(1)

    def _write_snap_file(self, snap_fname, snap_name):
        snap_fname = '/var/lib/zmt/%s' % snap_fname
        with open(snap_fname, 'w') as last_snap:
            last_snap.write(snap_name)

    def _get_snap_name(self, fq_snap_name):
        return fq_snap_name.split('@')[1]

    def _host_is_up(self, host):
        if '@' not in host:
            return True
        # check if host mirror is reachable
        cmd = 'ping -O -c 1 %s' % host
        ping_exitcode, ping_output = subprocess.getstatusoutput(cmd)
        if ping_exitcode == 0:
            return True
        else:
            return False

    def _to_filesystem(self, items):
        kind_items = []
        for item in items:
            if item in self.managed_vms and item in self.managed_containers:
                raise RuntimeError(
                    "The item name is ambiguous. Please be more specific with @vm or @container"
                )
            if '@vm' in item or '@container' in item:
                name, kind = item.split('@')
            else:
                if item in self.managed_vms:
                    kind = 'vm'
                if item in self.managed_containers:
                    kind = 'container'
                name = item
            kind_items.append(Filesystem(name, kind, self.config))
        return kind_items

    def autosnap(self):
        if not self.args.items and not self.running:
            print('No vms/containers running and no vm/container specified')
            exit(0)

        if self.args.items:
            fs_to_snap = self._to_filesystem(self.args.items)
        else:
            fs_to_snap = self.running
        if not os.path.exists('/var/lib/zmt/autosnap/'):
            os.makedirs('/var/lib/zmt/autosnap/')
        now_string = datetime.now().strftime(AUTOSNAP_DATESTR)
        snap_name = 'autosnap-%s' % now_string

        # create the local snapshots
        for fs in fs_to_snap:
            cmd = 'zfs snap -r {zfs_main}/{fs}@{snap_name}'.format(
                zfs_main=fs.zfs_main, fs=fs.name, snap_name=snap_name
            )
            subprocess.check_call(cmd, universal_newlines=True, shell=True)

        host_mirros_up = {}
        # send all snapshots over ssh to the host_mirror
        for fs in fs_to_snap:
            if fs.host_mirror and fs.host_mirror not in host_mirros_up:
                is_up = self._host_is_up(fs.host_mirror)
                host_mirros_up[fs.host_mirror] = is_up
            if fs.host_mirror and host_mirros_up[fs.host_mirror]:
                last_inc = self._get_inc_from_file(
                    'autosnap/%s' % fs.longname, inc_as_stream=True
                )
                # send fs to host mirror
                cmd = 'zfs send -R {inc} {zfs_main}/{fs}@{snap_name} |\
                       ssh {host_mirror} "zfs recv {zfs_main}/{fs}"'.format(
                    zfs_main=fs.zfs_main, fs=fs.name, host_mirror=fs.host_mirror,
                    inc=last_inc, snap_name=snap_name
                )
                subprocess.check_output(
                    cmd, universal_newlines=True, shell=True
                )

                # write last autosnap
                self._write_snap_file(
                    'autosnap/%s' % fs.longname, snap_name
                )
            else:
                if fs.host_mirror:
                    print("Mirror host is down, trying it next time")

    def moved(self):
        if not self.args.item:
            print('No vm/container specified')
            exit(0)
        else:
            fs = self.args.item[0]

        # write last autosnap from last zfs snaphost
        self._write_snap_file(
            'autosnap/%s' % fs.longname, self._get_last_snap_from_zfs(fs)
        )

    def backup(self):
        if not os.path.exists('/var/lib/zmt/backup/'):
            os.makedirs('/var/lib/zmt/backup/')

        # proccess all managed fs from zmt.ini
        for fs in self.managed_fs:
            last_inc = self._get_inc_from_file(
                'backup/%s' % fs.longname, inc_as_stream=False
            )

            # get all snapshots from tank
            cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs_main}/{fs}'.format(
                zfs_main=fs.zfs_main, fs=fs.name, inc=last_inc,
            )
            snap_names = subprocess.check_output(
                cmd, universal_newlines=True, shell=True
            ).splitlines()

            backup_snap_names = []
            for snap_name in snap_names:
                if "@autosnap-" in snap_name:
                    backup_snap_names.append(snap_name)
                    break
                else:
                    backup_snap_names.append(snap_name)
            backup_snap_names.reverse()
            backup_done = False

            # send the only the newest snapshot from tank to backup
            for snap_name in backup_snap_names:
                if (last_inc and not last_inc.split('@')[1] in snap_name) or (not last_inc):
                    cmd = 'zfs send -R {last_inc} {snap_name} | \
                           zfs recv -Fu {zfs_backup}/{fs}'.format(
                        zfs_backup=fs.zfs_backup, fs=fs.name, last_inc=last_inc,
                        snap_name=snap_name
                    )
                    subprocess.check_output(
                        cmd, universal_newlines=True, shell=True
                    )
                    backup_done = True
                    last_inc = '-i @%s' % self._get_snap_name(snap_name)
                else:
                    print("no newer snapshot to backup")

            if backup_done:
                # write last backupsnap
                self._write_snap_file(
                    'backup/%s' % fs.longname,
                    self._get_snap_name(backup_snap_names[-1])
                )

                # fix mountpoints
                cmd = 'zfs set mountpoint=/{zfs_backup}/{fs} {zfs_backup}/{fs}'.format(
                    zfs_backup=fs.zfs_backup, fs=fs.name,
                )
                subprocess.check_output(
                    cmd, universal_newlines=True, shell=True
                )

    def cleanup(self):
        autosnap_keep = int(self.config['autosnap']['keep'])
        for fs in self.config['vm']['managed'].split(','):
            fs = fs.strip()
            cmd = 'zfs list -H -S creation -r -o name -t snap -d 1 {zfs}/{fs} | \
                   grep "@autosnap-"'.format(
                zfs_main=self.config['vm']['zfs_main'], fs=fs
            )
            snaps = subprocess.check_output(
                cmd, universal_newlines=True, shell=True
            ).splitlines()
            if len(snaps) > autosnap_keep:
                for snap in snaps[autosnap_keep:]:
                    cmd = 'zfs destroy -r %s' % snap
                    snap_exitcode, snap_output = subprocess.getstatusoutput(cmd)

    def rsync(self):
        if self.args.host:
            rsync_hosts = [(
                self.args.host, self.config['rsync_hosts'][self.args.host]
            )]
        else:
            rsync_hosts = self.config.items('rsync_hosts')
        now_string = datetime.now().strftime(AUTOSNAP_DATESTR)
        verbose, dry_run = self.args.verbose, self.args.dry_run

        for fs, host_src in rsync_hosts:
            dest = '%s/%s' % (self.config['rsync']['dest_path'], fs)
            dest = dest if '/' == dest[:-1] else "%s/" % dest
            excludes = ['--exclude=%s' % exclude for exclude in self.config['rsync']['excludes'].split(',')]
            excludes.insert(0, '') # space between options
            host_src, delimiter, extra_options = host_src.partition('|')
            if extra_options:
                extra_options = extra_options.split('|')
                extra_options.insert(0, '') # space between options
            cmd = 'rsync {dry_run}{verbose}{options}{excludes}{extra_options} {host_src} {dest}'.format(
                dry_run=dry_run,
                verbose=verbose,
                options=self.config['rsync']['cmd_options'],
                excludes=' '.join(excludes),
                extra_options=' '.join(extra_options),
                host_src=host_src,
                dest=dest
            )
            # extract hostname
            host_name = host_src.split(':')[0].split('@')[-1]
            if verbose:
                print("* syncing host:%s" % host_name)
                print("* with command:\n%s\n" % cmd)
            if self._host_is_up(host_name):
                subprocess.check_call(
                    cmd.split(' '), universal_newlines=True
                )
                # metadata for the snapshot
                snap_conf = {
                    'zfs_backup': self.config['rsync']['zfs_backup'],
                    'name': 'autosnap-%s' % now_string
                }
                cmd = 'zfs snap -r {zfs_backup}/{fs}@{name}'.format(fs=fs.name, **snap_conf)
                if verbose:
                    print("* zfs snap with command:\n  %s" % cmd)
                if dry_run:
                    print("* zfs autosnap not done, in dry-run mode")
                else:
                    subprocess.check_call(cmd, shell=True)
            else:
                print("The host %s is down." % host_name)


class ZfsParser:
    def __init__(self):
        self.parser = argparse.ArgumentParser(
            description="""zfs management tools,
                           for snapshoting, replication, backup""")
        self.subparsers = self.parser.add_subparsers(
            help='avaiable commands')
        self.parser_autosnap(self.subparsers)
        self.parser_moved(self.subparsers)
        self.parser_backup(self.subparsers)
        self.parser_cleanup(self.subparsers)
        self.parser_rsync(self.subparsers)
        self.config = configparser.ConfigParser()
        self.config.read('/etc/zmt/zmt.ini')

    def run(self):
        args = self.parser.parse_args()
        if not hasattr(args, 'command'):
            self.parser.print_help()
            exit(0)
        zfstools = ZfsTools(args, self.config)

        if hasattr(zfstools, args.command):
            getattr(zfstools, args.command)()
        else:
            print('command %s not known' % args.command)

    def parser_autosnap(self, subparsers):
        parser_autosnap = self.subparsers.add_parser(
            'autosnap',
            help='create a snapshot'
        )
        parser_autosnap.add_argument('items', nargs='*', default=None)
        parser_autosnap.set_defaults(command='autosnap')

    def parser_moved(self, subparsers):
        parser_moved = self.subparsers.add_parser(
            'moved',
            help='set autosnap file to last snapshot'
        )
        parser_moved.add_argument('item', nargs=1)
        parser_moved.set_defaults(command='moved')

    def parser_backup(self, subparsers):
        parser_backup = self.subparsers.add_parser(
            'backup',
            help='create a backup'
        )
        parser_backup.set_defaults(command='backup')

    def parser_cleanup(self, subparsers):
        parser_cleanup = self.subparsers.add_parser(
            'cleanup',
            help='only keep the N recent snapshots'
        )
        parser_cleanup.set_defaults(command='cleanup')

    def parser_rsync(self, subparsers):
        parser_rsync = self.subparsers.add_parser(
            'rsync',
            help='only keep the N recent snapshots'
        )
        parser_rsync.add_argument('host', nargs='?', default=None)
        parser_rsync.add_argument(
            '-v', dest='verbose', const='-v ', action='store_const',
            default='', help='verbose'
        )
        parser_rsync.add_argument(
            '-n', dest='dry_run',  const='-n ', action='store_const',
            default='', help='dry-run'
        )
        parser_rsync.set_defaults(command='rsync')


def main():
    # main parser
    zfs_parser = ZfsParser()
    zfs_parser.run()


if __name__ == '__main__':
    main()
